diff --git a/Local Scope.xcodeproj/project.pbxproj b/Local Scope.xcodeproj/project.pbxproj
index ba4599f..abe192a 100644
--- a/Local Scope.xcodeproj/project.pbxproj	
+++ b/Local Scope.xcodeproj/project.pbxproj	
@@ -255,11 +255,13 @@
 				ENABLE_PREVIEWS = YES;
 				ENABLE_USER_SELECTED_FILES = readonly;
 				GENERATE_INFOPLIST_FILE = YES;
+				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.utilities";
 				INFOPLIST_KEY_NSHumanReadableCopyright = "";
 				LD_RUNPATH_SEARCH_PATHS = (
 					"$(inherited)",
 					"@executable_path/../Frameworks",
 				);
+				MACOSX_DEPLOYMENT_TARGET = 26.0;
 				MARKETING_VERSION = 1.0;
 				PRODUCT_BUNDLE_IDENTIFIER = "HobbyHome.Local-Scope";
 				PRODUCT_NAME = "$(TARGET_NAME)";
@@ -285,11 +287,13 @@
 				ENABLE_PREVIEWS = YES;
 				ENABLE_USER_SELECTED_FILES = readonly;
 				GENERATE_INFOPLIST_FILE = YES;
+				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.utilities";
 				INFOPLIST_KEY_NSHumanReadableCopyright = "";
 				LD_RUNPATH_SEARCH_PATHS = (
 					"$(inherited)",
 					"@executable_path/../Frameworks",
 				);
+				MACOSX_DEPLOYMENT_TARGET = 26.0;
 				MARKETING_VERSION = 1.0;
 				PRODUCT_BUNDLE_IDENTIFIER = "HobbyHome.Local-Scope";
 				PRODUCT_NAME = "$(TARGET_NAME)";
diff --git a/Local Scope.xcodeproj/project.xcworkspace/xcuserdata/kalyuzhniyko.xcuserdatad/UserInterfaceState.xcuserstate b/Local Scope.xcodeproj/project.xcworkspace/xcuserdata/kalyuzhniyko.xcuserdatad/UserInterfaceState.xcuserstate
index f1d0d82..4e052d9 100644
Binary files a/Local Scope.xcodeproj/project.xcworkspace/xcuserdata/kalyuzhniyko.xcuserdatad/UserInterfaceState.xcuserstate and b/Local Scope.xcodeproj/project.xcworkspace/xcuserdata/kalyuzhniyko.xcuserdatad/UserInterfaceState.xcuserstate differ
diff --git a/Local Scope.xcodeproj/xcuserdata/kalyuzhniyko.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist b/Local Scope.xcodeproj/xcuserdata/kalyuzhniyko.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist
new file mode 100644
index 0000000..43972a2
--- /dev/null
+++ b/Local Scope.xcodeproj/xcuserdata/kalyuzhniyko.xcuserdatad/xcdebugger/Breakpoints_v2.xcbkptlist	
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<Bucket
+   uuid = "C69713D5-C39C-4349-BDF5-A3717FDBF99E"
+   type = "1"
+   version = "2.0">
+</Bucket>
diff --git a/Local Scope/ContentView.swift b/Local Scope/ContentView.swift
deleted file mode 100644
index 9ee6318..0000000
--- a/Local Scope/ContentView.swift	
+++ /dev/null
@@ -1,195 +0,0 @@
-import SwiftUI
-
-struct Device: Identifiable {
-    let id = UUID()
-    let ip: String
-    let mac: String?
-    let type: String
-    let connection: String
-}
-
-struct ContentView: View {
-    @State private var devices: [Device] = []
-    @State private var isScanning = false
-    @State private var selectedTheme = "System"
-    let themes = ["System", "Light", "Dark", "Neon"]
-    @State private var history: [String] = []
-    private let historyFile = FileManager.default.homeDirectoryForCurrentUser.appendingPathComponent(".localscope/history.json").path
-
-    var body: some View {
-        TabView {
-            VStack {
-                Text("SSH Tab - Coming Soon")
-                    .font(.title)
-            }
-            .tabItem { Label("SSH", systemImage: "terminal") }
-
-            VStack {
-                Text("RDP Tab - Coming Soon")
-                    .font(.title)
-            }
-            .tabItem { Label("RDP", systemImage: "desktopcomputer") }
-
-            VStack {
-                Text("SFTP Tab - Coming Soon")
-                    .font(.title)
-            }
-            .tabItem { Label("SFTP", systemImage: "folder") }
-
-            VStack {
-                Button(action: scanNetwork) {
-                    Text(isScanning ? "Scanning..." : "Scan Network")
-                        .frame(maxWidth: .infinity)
-                        .padding()
-                        .background(isScanning ? .gray : .blue)
-                        .foregroundColor(.white)
-                        .cornerRadius(10)
-                }
-                .disabled(isScanning)
-
-                Canvas { context, size in
-                    let center = CGPoint(x: size.width / 2, y: size.height / 2)
-                    context.fill(Circle().path(in: CGRect(x: center.x - 20, y: center.y - 20, width: 40, height: 40)), with: .color(.green))
-                    context.draw(Text("My Mac\n\(getLocalIP() ?? "Unknown")"), at: CGPoint(x: center.x, y: center.y - 30))
-
-                    for (index, device) in devices.enumerated() {
-                        let angle = Double(index) * (2 * .pi / Double(max(devices.count, 1)))
-                        let radius = min(size.width, size.height) / 3
-                        let x = center.x + radius * cos(angle)
-                        let y = center.y + radius * sin(angle)
-
-                        context.stroke(Path { path in
-                            path.move(to: center)
-                            path.addLine(to: CGPoint(x: x, y: y))
-                        }, with: .color(device.connection == "Ethernet" ? .black : .gray), style: StrokeStyle(lineWidth: 2, dash: device.connection == "Wi-Fi" ? [5, 5] : []))
-
-                        let color = device.type == "Phone" ? .blue : device.type == "PC" ? .red : .purple
-                        context.fill(Circle().path(in: CGRect(x: x - 15, y: y - 15, width: 30, height: 30)), with: .color(color))
-                        context.draw(Text("\(device.ip)\n\(device.type)"), at: CGPoint(x: x, y: y - 25))
-                    }
-                }
-                .frame(width: 400, height: 400)
-                .background(.gray.opacity(0.1))
-                .cornerRadius(10)
-
-                List(devices, id: \.id) { device in
-                    Text("\(device.ip) - \(device.type) (\(device.connection))")
-                }
-            }
-            .tabItem { Label("Network Map", systemImage: "network") }
-
-            VStack {
-                Text("Settings")
-                    .font(.title)
-                Picker("Theme", selection: $selectedTheme) {
-                    ForEach(themes, id: \.self) { theme in
-                        Text(theme)
-                    }
-                }
-                .pickerStyle(MenuPickerStyle())
-                .padding()
-
-                Text("Selected Theme: \(selectedTheme)")
-                    .padding()
-            }
-            .tabItem { Label("Settings", systemImage: "gear") }
-        }
-        .frame(minWidth: 500, minHeight: 600)
-        .preferredColorScheme(selectedTheme == "System" ? nil : selectedTheme == "Dark" ? .dark : .light)
-        .onAppear(perform: loadHistory)
-        .onChange(of: devices) { _ in syncHistory() }
-    }
-
-    func scanNetwork() {
-        guard !isScanning else { return }
-        isScanning = true
-        devices.removeAll()
-
-        // Simulate network scan (replace with MMLanScan later)
-        DispatchQueue.main.asyncAfter(deadline: .now() + 2) {
-            devices = [
-                Device(ip: "192.168.1.100", mac: "00:14:22:01:23:45", type: "Phone", connection: "Wi-Fi"),
-                Device(ip: "192.168.1.101", mac: "00:16:17:04:56:78", type: "PC", connection: "Ethernet"),
-                Device(ip: "192.168.1.102", mac: "00:18:19:07:89:01", type: "TV", connection: "Wi-Fi")
-            ]
-            isScanning = false
-            syncHistory()
-        }
-    }
-
-    func getLocalIP() -> String? {
-        var address: String?
-        if let interfaces = Host.current().addresses {
-            for interface in interfaces {
-                if interface.contains("192.168.") || interface.contains("10.") || interface.contains("172.") {
-                    address = interface
-                    break
-                }
-            }
-        }
-        return address
-    }
-
-    func loadHistory() {
-        let fileManager = FileManager.default
-        if fileManager.fileExists(atPath: historyFile) {
-            if let data = try? Data(contentsOf: URL(fileURLWithPath: historyFile)),
-               let saved = try? JSONDecoder().decode([String].self, from: data) {
-                history = saved
-            }
-        }
-    }
-
-    func syncHistory() {
-        let currentDevices = devices.map { $0.ip }
-        history.append(contentsOf: currentDevices.filter { !history.contains($0) })
-        if let data = try? JSONEncoder().encode(history) {
-            try? data.write(to: URL(fileURLWithPath: historyFile))
-            syncToGitHub()
-        }
-    }
-
-    func syncToGitHub() {
-        let repoPath = FileManager.default.homeDirectoryForCurrentUser.appendingPathComponent(".localscope").path
-        if !FileManager.default.fileExists(atPath: repoPath) {
-            try? FileManager.default.createDirectory(atPath: repoPath, withIntermediateDirectories: true)
-            let process = Process()
-            process.executableURL = URL(fileURLWithPath: "/usr/bin/git")
-            process.arguments = ["init", repoPath]
-            try? process.run()
-            process.waitUntilExit()
-            process.arguments = ["remote", "add", "origin", "https://github.com/KalyuzhniyKO/LocalScope.git"]
-            try? process.run()
-            process.waitUntilExit()
-            try? Data("Initial config\n".utf8).write(to: URL(fileURLWithPath: repoPath + "/README.md"))
-            process.arguments = ["add", "."]
-            try? process.run()
-            process.waitUntilExit()
-            process.arguments = ["commit", "-m", "Initial commit"]
-            try? process.run()
-            process.waitUntilExit()
-            process.arguments = ["push", "-u", "origin", "main"]
-            try? process.run()
-            process.waitUntilExit()
-        } else {
-            let process = Process()
-            process.executableURL = URL(fileURLWithPath: "/usr/bin/git")
-            process.currentDirectoryURL = URL(fileURLWithPath: repoPath)
-            process.arguments = ["add", "."]
-            try? process.run()
-            process.waitUntilExit()
-            process.arguments = ["commit", "-m", "Update history: \(Date())"]
-            try? process.run()
-            process.waitUntilExit()
-            if process.terminationStatus == 0 {
-                process.arguments = ["push"]
-                try? process.run()
-                process.waitUntilExit()
-            }
-        }
-    }
-}
-
-#Preview {
-    ContentView()
-}
diff --git a/Local Scope/Local_ScopeApp.swift b/Local Scope/Local_ScopeApp.swift
index fc17773..881fcc1 100644
--- a/Local Scope/Local_ScopeApp.swift	
+++ b/Local Scope/Local_ScopeApp.swift	
@@ -2,7 +2,9 @@
 //  Local_ScopeApp.swift
 //  Local Scope
 //
-//  Created by KalyuzhniyKO on 08.10.2025.
+//  –¢–û–ß–ö–ê –í–•–û–î–ê –í –ü–†–ò–õ–û–ñ–ï–ù–ò–ï
+//  - –ó–∞–ø—É—Å–∫–∞–µ—Ç ContentView (–≥–ª–∞–≤–Ω—ã–π —ç–∫—Ä–∞–Ω)
+//  - –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Ä–∞–∑–º–µ—Ä –æ–∫–Ω–∞
 //
 
 import SwiftUI
@@ -13,5 +15,6 @@ struct Local_ScopeApp: App {
         WindowGroup {
             ContentView()
         }
+        .windowResizability(.contentSize)
     }
 }
diff --git a/Local Scope/Models/Device.swift b/Local Scope/Models/Device.swift
new file mode 100644
index 0000000..b4b0079
--- /dev/null
+++ b/Local Scope/Models/Device.swift	
@@ -0,0 +1,31 @@
+//
+//  Device.swift
+//  Local Scope
+//
+
+import Foundation
+
+struct Device: Identifiable, Hashable, Codable {
+    var id = UUID()
+    var name: String
+    var ip: String
+    var mac: String?
+    var type: String
+    var lastSeen: Date
+    var availableServices: [ServiceType] = []
+    var isFavorite: Bool = false
+    var favoriteServices: [ServiceType] = []
+    
+    init(name: String, ip: String, mac: String? = nil, type: String = "Unknown",
+         lastSeen: Date = Date(), availableServices: [ServiceType] = [],
+         isFavorite: Bool = false, favoriteServices: [ServiceType] = []) {
+        self.name = name
+        self.ip = ip
+        self.mac = mac
+        self.type = type
+        self.lastSeen = lastSeen
+        self.availableServices = availableServices
+        self.isFavorite = isFavorite
+        self.favoriteServices = favoriteServices
+    }
+}
diff --git a/Local Scope/Models/ServiceType.swift b/Local Scope/Models/ServiceType.swift
new file mode 100644
index 0000000..1d7635a
--- /dev/null
+++ b/Local Scope/Models/ServiceType.swift	
@@ -0,0 +1,42 @@
+//
+//  ServiceType.swift
+//  Local Scope
+//
+
+import SwiftUI
+
+enum ServiceType: String, Codable, CaseIterable {
+    case ssh = "SSH"
+    case rdp = "RDP"
+    case ftp = "FTP"
+    case sftp = "SFTP"
+    case vnc = "VNC"
+    
+    var icon: String {
+        switch self {
+        case .ssh: return "terminal"
+        case .rdp: return "desktopcomputer"
+        case .ftp, .sftp: return "folder"
+        case .vnc: return "tv"
+        }
+    }
+    
+    var port: Int {
+        switch self {
+        case .ssh: return 22
+        case .rdp: return 3389
+        case .ftp: return 21
+        case .sftp: return 22
+        case .vnc: return 5900
+        }
+    }
+    
+    var color: Color {
+        switch self {
+        case .ssh: return .blue
+        case .rdp: return .purple
+        case .ftp, .sftp: return .orange
+        case .vnc: return .green
+        }
+    }
+}
diff --git a/Local Scope/Services/DeviceDetector.swift b/Local Scope/Services/DeviceDetector.swift
new file mode 100644
index 0000000..d74776d
--- /dev/null
+++ b/Local Scope/Services/DeviceDetector.swift	
@@ -0,0 +1,138 @@
+//
+//  DeviceDetector.swift
+//  Local Scope
+//
+//  –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –ø–æ MAC-–∞–¥—Ä–µ—Å—É
+//
+
+import Foundation
+
+struct DeviceDetector {
+    
+    // MARK: - –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
+    static func detectType(mac: String?, ip: String) -> String {
+        guard let mac = mac else { return "‚ùì Unknown Device" }
+        
+        let prefix = mac.prefix(8).uppercased()
+        
+        // –†–æ—É—Ç–µ—Ä—ã
+        if ip.hasSuffix(".1") || isRouter(prefix) {
+            return "üåê Router"
+        }
+        
+        // Apple —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
+        if isApple(prefix) {
+            return "üì± Apple Device"
+        }
+        
+        // Android —Å–º–∞—Ä—Ç—Ñ–æ–Ω—ã
+        if isAndroid(prefix) {
+            return "üì± Android Phone"
+        }
+        
+        // Smart TV
+        if isSmartTV(prefix) {
+            return "üì∫ Smart TV"
+        }
+        
+        // –ë—ã—Ç–æ–≤–∞—è —Ç–µ—Ö–Ω–∏–∫–∞
+        if isAppliance(prefix) {
+            return "üß∫ Smart Appliance"
+        }
+        
+        // –£–º–Ω—ã–π –¥–æ–º
+        if isSmartHome(prefix) {
+            return "üè† Smart Home"
+        }
+        
+        // –ò–≥—Ä–æ–≤—ã–µ –∫–æ–Ω—Å–æ–ª–∏
+        if isGamingConsole(prefix) {
+            return "üéÆ Gaming Console"
+        }
+        
+        // Raspberry Pi
+        if isRaspberryPi(prefix) {
+            return "üçì Raspberry Pi"
+        }
+        
+        // NAS
+        if isNAS(prefix) {
+            return "üíæ NAS Storage"
+        }
+        
+        // –ü—Ä–∏–Ω—Ç–µ—Ä—ã
+        if isPrinter(prefix) {
+            return "üñ®Ô∏è Printer"
+        }
+        
+        return "üíª Network Device"
+    }
+    
+    // MARK: - –ü—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å–∞–º MAC
+    
+    private static func isRouter(_ prefix: String) -> Bool {
+        ["00:1D:7E", "F8:1A:67", "A0:F3:C1", "C4:E9:84",
+         "88:D7:F6", "34:CE:00", "78:11:DC", "C8:3A:35",
+         "00:14:D1", "00:22:B0", "00:1B:11", "20:E5:2A",
+         "04:D4:C4", "AC:9E:17"].contains(where: { prefix.hasPrefix($0) })
+    }
+    
+    private static func isApple(_ prefix: String) -> Bool {
+        ["AC:DE:48", "00:CD:FE", "00:A0:40", "3C:AB:8E",
+         "68:96:7B", "F8:1E:DF", "A4:83:E7", "BC:3B:AF",
+         "EC:35:86", "F4:0F:24"].contains(where: { prefix.hasPrefix($0) })
+    }
+    
+    private static func isAndroid(_ prefix: String) -> Bool {
+        ["D8:C4:6A", "E8:50:8B", "34:2D:0D", "B4:F0:AB",
+         "08:EB:ED", "78:F8:82", "6C:F3:73", "40:4E:36",
+         "C0:EE:FB", "AC:37:43", "38:D5:47", "74:23:44",
+         "F8:A4:5F", "50:8F:4C", "64:09:80", "C4:0B:CB",
+         "00:18:82", "AC:E2:D3", "F8:E6:1A", "D4:61:DA",
+         "C8:D0:83", "D0:74:E5", "E0:B9:4D"].contains(where: { prefix.hasPrefix($0) })
+    }
+    
+    private static func isSmartTV(_ prefix: String) -> Bool {
+        ["00:E0:91", "B8:BB:AF", "78:5D:C8", "00:1C:62",
+         "A0:39:F7", "BC:8C:CD", "50:32:37", "CC:6E:A4",
+         "70:2A:D5", "00:26:37", "E8:5B:5B", "84:25:DB",
+         "FC:F1:52", "DC:D3:A2", "04:4E:AF", "64:90:C1",
+         "00:04:1F"].contains(where: { prefix.hasPrefix($0) })
+    }
+    
+    private static func isAppliance(_ prefix: String) -> Bool {
+        ["54:60:09", "00:23:A4", "18:B7:9E", "68:C9:0B",
+         "00:12:48", "00:1D:BC", "D0:D0:03", "00:19:C8",
+         "00:03:19", "00:1E:C2", "00:0E:58", "F0:D5:BF",
+         "9C:E3:3F", "54:A0:50", "6C:D6:8A"].contains(where: { prefix.hasPrefix($0) })
+    }
+    
+    private static func isSmartHome(_ prefix: String) -> Bool {
+        ["EC:FA:BC", "00:FC:8B", "38:F7:3D", "FC:A6:67",
+         "F0:D2:F1", "54:60:09", "18:B4:30", "64:16:66",
+         "D8:31:CF", "78:11:DC", "04:CF:8C", "50:EC:50",
+         "68:57:2D"].contains(where: { prefix.hasPrefix($0) })
+    }
+    
+    private static func isGamingConsole(_ prefix: String) -> Bool {
+        ["00:1F:EA", "00:04:1F", "FC:0F:E6", "7C:BB:8A",
+         "00:50:F2", "98:5F:D3", "00:1B:EA", "00:17:AB",
+         "00:09:BF", "A4:5E:60"].contains(where: { prefix.hasPrefix($0) })
+    }
+    
+    private static func isRaspberryPi(_ prefix: String) -> Bool {
+        ["DC:A6:32", "B8:27:EB", "E4:5F:01", "D8:3A:DD"]
+            .contains(where: { prefix.hasPrefix($0) })
+    }
+    
+    private static func isNAS(_ prefix: String) -> Bool {
+        ["00:11:32", "24:5E:BE", "00:08:9B"]
+            .contains(where: { prefix.hasPrefix($0) })
+    }
+    
+    private static func isPrinter(_ prefix: String) -> Bool {
+        ["00:25:B3", "98:E7:F4", "00:1E:C9", "00:00:85",
+         "00:1B:A9", "30:05:5C", "00:1C:CC", "64:EB:8C"]
+            .contains(where: { prefix.hasPrefix($0) })
+    }
+}
diff --git a/Local Scope/Services/NetworkScanner.swift b/Local Scope/Services/NetworkScanner.swift
new file mode 100644
index 0000000..3e25ca0
--- /dev/null
+++ b/Local Scope/Services/NetworkScanner.swift	
@@ -0,0 +1,145 @@
+//
+//  NetworkScanner.swift
+//  Local Scope
+//
+//  –†–µ–∞–ª—å–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–µ—Ç–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º ping –∏ ARP
+//
+
+import Foundation
+import Darwin
+
+actor NetworkScanner {
+    
+    // MARK: - –ü–æ–ª—É—á–µ–Ω–∏–µ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ IP
+    func getLocalIP() async -> String? {
+        await withCheckedContinuation { continuation in
+            var ifaddr: UnsafeMutablePointer<ifaddrs>?
+            guard getifaddrs(&ifaddr) == 0 else {
+                continuation.resume(returning: nil)
+                return
+            }
+            defer { freeifaddrs(ifaddr) }
+            
+            var ptr = ifaddr
+            while ptr != nil {
+                let interface = ptr!.pointee
+                let name = String(cString: interface.ifa_name)
+                
+                if name.hasPrefix("en"), interface.ifa_addr.pointee.sa_family == UInt8(AF_INET) {
+                    var hostname = [CChar](repeating: 0, count: Int(NI_MAXHOST))
+                    getnameinfo(
+                        interface.ifa_addr,
+                        socklen_t(interface.ifa_addr.pointee.sa_len),
+                        &hostname,
+                        socklen_t(hostname.count),
+                        nil, 0, NI_NUMERICHOST
+                    )
+                    continuation.resume(returning: String(cString: hostname))
+                    return
+                }
+                ptr = interface.ifa_next
+            }
+            continuation.resume(returning: nil)
+        }
+    }
+    
+    // MARK: - –ë—ã—Å—Ç—Ä—ã–π Ping –ø–æ–¥—Å–µ—Ç–∏
+    func quickPingSubnet(subnet: String) async {
+        await withTaskGroup(of: Void.self) { group in
+            for i in 1...254 {
+                group.addTask {
+                    _ = await self.ping(ip: "\(subnet).\(i)")
+                }
+            }
+        }
+    }
+    
+    private func ping(ip: String) async -> Bool {
+        await withCheckedContinuation { continuation in
+            let process = Process()
+            process.executableURL = URL(fileURLWithPath: "/sbin/ping")
+            process.arguments = ["-c", "1", "-W", "200", ip]
+            process.standardOutput = Pipe()
+            process.standardError = Pipe()
+            
+            do {
+                try process.run()
+                process.terminationHandler = { proc in
+                    continuation.resume(returning: proc.terminationStatus == 0)
+                }
+            } catch {
+                continuation.resume(returning: false)
+            }
+        }
+    }
+    
+    // MARK: - –ü–∞—Ä—Å–∏–Ω–≥ ARP —Ç–∞–±–ª–∏—Ü—ã
+    func parseARPTable(subnet: String, excludeIP: String?) async -> [Device] {
+        await withCheckedContinuation { continuation in
+            let process = Process()
+            process.executableURL = URL(fileURLWithPath: "/usr/sbin/arp")
+            process.arguments = ["-a"]
+            
+            let pipe = Pipe()
+            process.standardOutput = pipe
+            
+            do {
+                try process.run()
+                process.waitUntilExit()
+                
+                let data = pipe.fileHandleForReading.readDataToEndOfFile()
+                guard let output = String(data: data, encoding: .utf8) else {
+                    continuation.resume(returning: [])
+                    return
+                }
+                
+                var foundDevices: [Device] = []
+                let lines = output.components(separatedBy: .newlines)
+                
+                for line in lines {
+                    guard line.contains(subnet) else { continue }
+                    
+                    let components = line.components(separatedBy: " ")
+                    guard let ipStart = components.firstIndex(where: { $0.hasPrefix("(") }),
+                          ipStart < components.count else { continue }
+                    
+                    let ipString = components[ipStart]
+                        .trimmingCharacters(in: CharacterSet(charactersIn: "()"))
+                    
+                    // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–≤–æ–π IP
+                    if ipString == excludeIP { continue }
+                    
+                    // –ò–∑–≤–ª–µ–∫–∞–µ–º MAC –∞–¥—Ä–µ—Å
+                    var macAddress: String?
+                    if let atIndex = components.firstIndex(of: "at"),
+                       atIndex + 1 < components.count {
+                        macAddress = components[atIndex + 1]
+                    }
+                    
+                    let deviceType = DeviceDetector.detectType(mac: macAddress, ip: ipString)
+                    
+                    let device = Device(
+                        name: deviceType,
+                        ip: ipString,
+                        mac: macAddress,
+                        type: deviceType,
+                        lastSeen: Date()
+                    )
+                    
+                    foundDevices.append(device)
+                }
+                
+                continuation.resume(returning: foundDevices.sorted { $0.ip < $1.ip })
+            } catch {
+                continuation.resume(returning: [])
+            }
+        }
+    }
+    
+    // MARK: - –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –ø–æ–¥—Å–µ—Ç–∏ (NONISOLATED - –º–æ–∂–Ω–æ –≤—ã–∑—ã–≤–∞—Ç—å —Å–Ω–∞—Ä—É–∂–∏)
+    nonisolated func extractSubnet(from ip: String) -> String? {
+        let parts = ip.split(separator: ".")
+        guard parts.count == 4 else { return nil }
+        return parts.dropLast().joined(separator: ".")
+    }
+}
diff --git a/Local Scope/Services/PortScanner.swift b/Local Scope/Services/PortScanner.swift
new file mode 100644
index 0000000..e182efd
--- /dev/null
+++ b/Local Scope/Services/PortScanner.swift	
@@ -0,0 +1,100 @@
+//
+//  PortScanner.swift
+//  Local Scope
+//
+//  –†–µ–∞–ª—å–Ω–æ–µ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç—ã—Ö –ø–æ—Ä—Ç–æ–≤
+//
+
+import Foundation
+import Darwin
+
+actor PortScanner {
+    
+    // MARK: - –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ –Ω–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞—Ö
+    func scanServicesForDevices(_ devices: [Device]) async -> [Device] {
+        var updatedDevices = devices
+        let servicesToScan: [ServiceType] = [.ssh, .rdp, .ftp, .vnc]
+        
+        await withTaskGroup(of: (Int, [ServiceType]).self) { group in
+            for (index, device) in updatedDevices.enumerated() {
+                group.addTask {
+                    var availableServices: [ServiceType] = []
+                    
+                    for service in servicesToScan {
+                        if await self.checkPort(ip: device.ip, port: service.port) {
+                            availableServices.append(service)
+                        }
+                    }
+                    
+                    return (index, availableServices)
+                }
+            }
+            
+            for await (index, services) in group {
+                updatedDevices[index].availableServices = services
+            }
+        }
+        
+        return updatedDevices
+    }
+    
+    // MARK: - –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ–¥–Ω–æ–≥–æ –ø–æ—Ä—Ç–∞
+    func checkPort(ip: String, port: Int) async -> Bool {
+        await withCheckedContinuation { continuation in
+            DispatchQueue.global(qos: .userInitiated).async {
+                var addr = sockaddr_in()
+                addr.sin_family = sa_family_t(AF_INET)
+                addr.sin_port = UInt16(port).bigEndian
+                addr.sin_addr.s_addr = inet_addr(ip)
+                
+                let sock = socket(AF_INET, SOCK_STREAM, 0)
+                guard sock >= 0 else {
+                    continuation.resume(returning: false)
+                    return
+                }
+                defer { close(sock) }
+                
+                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–∞—É—Ç
+                var timeout = timeval(tv_sec: 0, tv_usec: 500000) // 500ms
+                setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &timeout, socklen_t(MemoryLayout<timeval>.size))
+                setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, &timeout, socklen_t(MemoryLayout<timeval>.size))
+                
+                // Non-blocking —Ä–µ–∂–∏–º
+                fcntl(sock, F_SETFL, fcntl(sock, F_GETFL, 0) | O_NONBLOCK)
+                
+                let result = withUnsafePointer(to: &addr) {
+                    $0.withMemoryRebound(to: sockaddr.self, capacity: 1) {
+                        connect(sock, $0, socklen_t(MemoryLayout<sockaddr_in>.size))
+                    }
+                }
+                
+                if result == 0 {
+                    continuation.resume(returning: true)
+                } else if errno == EINPROGRESS || errno == EALREADY {
+                    // –ñ–¥–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è —Å –ø–æ–º–æ—â—å—é select
+                    var writefds = fd_set()
+                    withUnsafeMutablePointer(to: &writefds) { ptr in
+                        ptr.pointee.fds_bits = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
+                        let fdIndex = Int(sock) / 32
+                        let fdBit = Int(sock) % 32
+                        ptr.pointee.fds_bits.0 |= Int32(1 << fdBit)
+                    }
+                    
+                    var selectTimeout = timeval(tv_sec: 0, tv_usec: 500000)
+                    let selectResult = select(sock + 1, nil, &writefds, nil, &selectTimeout)
+                    
+                    if selectResult > 0 {
+                        var error: Int32 = 0
+                        var errorLen = socklen_t(MemoryLayout<Int32>.size)
+                        getsockopt(sock, SOL_SOCKET, SO_ERROR, &error, &errorLen)
+                        continuation.resume(returning: error == 0)
+                    } else {
+                        continuation.resume(returning: false)
+                    }
+                } else {
+                    continuation.resume(returning: false)
+                }
+            }
+        }
+    }
+}
diff --git a/Local Scope/ViewModels/ConnectionManager.swift b/Local Scope/ViewModels/ConnectionManager.swift
new file mode 100644
index 0000000..d699e19
--- /dev/null
+++ b/Local Scope/ViewModels/ConnectionManager.swift	
@@ -0,0 +1,84 @@
+//
+//  ConnectionManager.swift
+//  Local Scope
+//
+//  –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è–º–∏ –∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º
+//
+
+import Foundation
+import AppKit
+
+actor ConnectionManager {
+    
+    // MARK: - Connect to Device
+    func connect(to device: Device, using service: ServiceType) async -> (success: Bool, message: String) {
+        switch service {
+        case .ssh:
+            return await connectSSH(ip: device.ip)
+        case .rdp:
+            return await connectRDP(ip: device.ip)
+        case .ftp:
+            return await connectFTP(ip: device.ip)
+        case .sftp:
+            return await connectSFTP(ip: device.ip)
+        case .vnc:
+            return await connectVNC(ip: device.ip)
+        }
+    }
+    
+    // MARK: - SSH Connection
+    // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —É—Å–ø–µ—Ö, —á—Ç–æ–±—ã ContentView –æ—Ç–∫—Ä—ã–ª –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π —Ç–µ—Ä–º–∏–Ω–∞–ª
+    private func connectSSH(ip: String) async -> (success: Bool, message: String) {
+        return (true, "Opening SSH terminal for \(ip)")
+    }
+    
+    // MARK: - RDP Connection
+    private func connectRDP(ip: String) async -> (success: Bool, message: String) {
+        await MainActor.run {
+            let process = Process()
+            process.executableURL = URL(fileURLWithPath: "/usr/bin/open")
+            process.arguments = ["-a", "Microsoft Remote Desktop", "rdp://\(ip)"]
+            
+            do {
+                try process.run()
+                process.waitUntilExit()
+                
+                if process.terminationStatus == 0 {
+                    return (true, "RDP connection opened")
+                } else {
+                    if let url = URL(string: "rdp://\(ip)") {
+                        NSWorkspace.shared.open(url)
+                        return (true, "RDP connection opened")
+                    }
+                    return (false, "Failed to open RDP connection")
+                }
+            } catch {
+                return (false, "Microsoft Remote Desktop not installed")
+            }
+        }
+    }
+    
+    // MARK: - FTP Connection
+    private func connectFTP(ip: String) async -> (success: Bool, message: String) {
+        // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —É—Å–ø–µ—Ö, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª–æ–≤—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä
+        return (true, "Opening FTP file manager for \(ip)")
+    }
+    
+    // MARK: - SFTP Connection
+    private func connectSFTP(ip: String) async -> (success: Bool, message: String) {
+        // –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —É—Å–ø–µ—Ö, —á—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª–æ–≤—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä
+        return (true, "Opening SFTP file manager for \(ip)")
+    }
+    
+    // MARK: - VNC Connection
+    private func connectVNC(ip: String) async -> (success: Bool, message: String) {
+        guard let url = URL(string: "vnc://\(ip)") else {
+            return (false, "Invalid VNC URL")
+        }
+        
+        return await MainActor.run {
+            NSWorkspace.shared.open(url)
+            return (true, "VNC connection opened")
+        }
+    }
+}
diff --git a/Local Scope/ViewModels/HistoryManager.swift b/Local Scope/ViewModels/HistoryManager.swift
new file mode 100644
index 0000000..81456f6
--- /dev/null
+++ b/Local Scope/ViewModels/HistoryManager.swift	
@@ -0,0 +1,76 @@
+//
+//  HistoryManager.swift
+//  Local Scope
+//
+//  –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏—Å—Ç–æ—Ä–∏–µ–π —É—Å—Ç—Ä–æ–π—Å—Ç–≤
+//
+
+import Foundation
+
+actor HistoryManager {
+    private let fileURL: URL
+    
+    init() {
+        self.fileURL = FileManager.default.homeDirectoryForCurrentUser
+            .appendingPathComponent(".localscope/history.json")
+    }
+    
+    // MARK: - Load History
+    func loadHistory() async -> [Device] {
+        guard FileManager.default.fileExists(atPath: fileURL.path) else {
+            return []
+        }
+        
+        do {
+            let data = try Data(contentsOf: fileURL)
+            let devices = try JSONDecoder().decode([Device].self, from: data)
+            return devices
+        } catch {
+            print("‚ùå Failed to load history: \(error)")
+            return []
+        }
+    }
+    
+    // MARK: - Save History
+    func saveHistory(_ devices: [Device]) async -> Bool {
+        do {
+            try FileManager.default.createDirectory(
+                at: fileURL.deletingLastPathComponent(),
+                withIntermediateDirectories: true
+            )
+            
+            let data = try JSONEncoder().encode(devices)
+            try data.write(to: fileURL)
+            return true
+        } catch {
+            print("‚ùå Failed to save history: \(error)")
+            return false
+        }
+    }
+    
+    // MARK: - Clear History
+    func clearHistory() async -> Bool {
+        do {
+            if FileManager.default.fileExists(atPath: fileURL.path) {
+                try FileManager.default.removeItem(at: fileURL)
+            }
+            return true
+        } catch {
+            print("‚ùå Failed to clear history: \(error)")
+            return false
+        }
+    }
+    
+    // MARK: - Update Device
+    func updateDevice(_ device: Device, in history: [Device]) -> [Device] {
+        var updatedHistory = history
+        
+        if let index = updatedHistory.firstIndex(where: { $0.ip == device.ip }) {
+            updatedHistory[index] = device
+        } else {
+            updatedHistory.append(device)
+        }
+        
+        return updatedHistory
+    }
+}
diff --git a/Local Scope/ViewModels/NetworkScannerViewModel.swift b/Local Scope/ViewModels/NetworkScannerViewModel.swift
new file mode 100644
index 0000000..cc9361e
--- /dev/null
+++ b/Local Scope/ViewModels/NetworkScannerViewModel.swift	
@@ -0,0 +1,160 @@
+//
+//  NetworkScannerViewModel.swift
+//  Local Scope
+//
+//  ViewModel –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ–º —Å–µ—Ç–∏
+//
+
+import SwiftUI
+import Foundation
+import Combine
+
+@MainActor
+final class NetworkScannerViewModel: ObservableObject {
+    // MARK: - Published Properties
+    @Published var devices: [Device] = []
+    @Published var history: [Device] = []
+    @Published var localIP: String = "Detecting..."
+    @Published var scanning = false
+    @Published var progress: Double = 0.0
+    @Published var syncStatus: String = ""
+    
+    // MARK: - Private Properties
+    private let networkScanner = NetworkScanner()
+    private let portScanner = PortScanner()
+    private let historyManager = HistoryManager()
+    private let connectionManager = ConnectionManager()
+    
+    // MARK: - Initialization
+    init() {
+        Task {
+            await initialize()
+        }
+    }
+    
+    private func initialize() async {
+        localIP = await networkScanner.getLocalIP() ?? "Unavailable"
+        await loadHistory()
+    }
+    
+    // MARK: - Network Scanning
+    func scanNetwork() {
+        guard !scanning else {
+            scanning = false
+            return
+        }
+        
+        Task {
+            scanning = true
+            progress = 0.0
+            devices.removeAll()
+            
+            guard let local = await networkScanner.getLocalIP(),
+                  let subnet = networkScanner.extractSubnet(from: local) else {
+                scanning = false
+                syncStatus = "‚ùå Failed to detect local IP"
+                return
+            }
+            
+            syncStatus = "üîç Pinging subnet..."
+            await networkScanner.quickPingSubnet(subnet: subnet)
+            progress = 0.5
+            
+            syncStatus = "üì° Reading ARP table..."
+            var arpDevices = await networkScanner.parseARPTable(subnet: subnet, excludeIP: local)
+            progress = 0.7
+            
+            syncStatus = "üîé Scanning services..."
+            arpDevices = await portScanner.scanServicesForDevices(arpDevices)
+            progress = 0.9
+            
+            devices = arpDevices
+            scanning = false
+            progress = 1.0
+            syncStatus = "‚úÖ Found \(devices.count) device(s)"
+            
+            for device in devices {
+                history = await historyManager.updateDevice(device, in: history)
+            }
+            await saveHistory()
+        }
+    }
+    
+    // MARK: - History Management
+    func loadHistory() async {
+        history = await historyManager.loadHistory()
+    }
+    
+    private func saveHistory() async {
+        let success = await historyManager.saveHistory(history)
+        if !success {
+            syncStatus = "‚ùå Failed to save history"
+        }
+    }
+    
+    func clearHistory() {
+        Task {
+            let success = await historyManager.clearHistory()
+            history.removeAll()
+            syncStatus = success ? "‚úÖ History cleared" : "‚ùå Failed to clear history"
+        }
+    }
+    
+    // MARK: - Delete from History (–ù–û–í–´–ô –ú–ï–¢–û–î!)
+    func deleteFromHistory(device: Device) {
+        Task {
+            history.removeAll { $0.ip == device.ip }
+            await saveHistory()
+            syncStatus = "üóëÔ∏è Removed \(device.name) from history"
+        }
+    }
+    
+    // MARK: - Manual Device Management
+    func addManualDevice(_ device: Device) {
+        Task {
+            history = await historyManager.updateDevice(device, in: history)
+            
+            if !devices.contains(where: { $0.ip == device.ip }) {
+                devices.append(device)
+            }
+            
+            await saveHistory()
+            syncStatus = "‚úÖ Device \(device.ip) added manually"
+        }
+    }
+    
+    // MARK: - Connection
+    func connectToDevice(_ device: Device, service: ServiceType) {
+        Task {
+            syncStatus = "üîó Connecting to \(device.ip) via \(service.rawValue)..."
+            
+            let result = await connectionManager.connect(to: device, using: service)
+            syncStatus = result.success ? "‚úÖ \(result.message)" : "‚ùå \(result.message)"
+        }
+    }
+    
+    // MARK: - Favorites Management
+    func toggleFavorite(device: Device, service: ServiceType) {
+        Task {
+            if let index = history.firstIndex(where: { $0.ip == device.ip }) {
+                var updatedDevice = history[index]
+                
+                if updatedDevice.favoriteServices.contains(service) {
+                    updatedDevice.favoriteServices.removeAll { $0 == service }
+                    syncStatus = "‚ùå Removed \(service.rawValue) from favorites"
+                } else {
+                    updatedDevice.favoriteServices.append(service)
+                    syncStatus = "‚≠ê Added \(service.rawValue) to favorites"
+                }
+                
+                history[index] = updatedDevice
+                
+                if let deviceIndex = devices.firstIndex(where: { $0.ip == device.ip }) {
+                    devices[deviceIndex] = updatedDevice
+                }
+                
+                await saveHistory()
+            }
+        }
+    }
+}
diff --git a/Local Scope/Views/Components/AddDeviceSheet.swift b/Local Scope/Views/Components/AddDeviceSheet.swift
new file mode 100644
index 0000000..77535c3
--- /dev/null
+++ b/Local Scope/Views/Components/AddDeviceSheet.swift	
@@ -0,0 +1,143 @@
+//
+//  AddDeviceSheet.swift
+//  Local Scope
+//
+//  –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –¥–ª—è —Ä—É—á–Ω–æ–≥–æ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
+//  - –ü–æ–ª–µ "–ò–º—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞" (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ)
+//  - –ü–æ–ª–µ "IP –∞–¥—Ä–µ—Å" (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ)
+//  - –í–∞–ª–∏–¥–∞—Ü–∏—è IP –∞–¥—Ä–µ—Å–∞ (–ø—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ xxx.xxx.xxx.xxx)
+//  - –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ç–∏–ø —Å–µ—Ä–≤–∏—Å–∞ (SSH/RDP/FTP)
+//
+
+import SwiftUI
+
+struct AddDeviceSheet: View {
+    let serviceType: ServiceType
+    let onAdd: (Device) -> Void
+    @Environment(\.dismiss) var dismiss
+    
+    @State private var deviceName: String = ""
+    @State private var ipAddress: String = ""
+    @State private var showError: Bool = false
+    @State private var errorMessage: String = ""
+    
+    var body: some View {
+        VStack(spacing: 20) {
+            // HEADER - –®–∞–ø–∫–∞ –æ–∫–Ω–∞ —Å –∏–∫–æ–Ω–∫–æ–π –∏ –∫–Ω–æ–ø–∫–æ–π –∑–∞–∫—Ä—ã—Ç–∏—è
+            HStack {
+                ZStack {
+                    Circle()
+                        .fill(serviceType.color.opacity(0.2))
+                        .frame(width: 50, height: 50)
+                    Image(systemName: serviceType.icon)
+                        .font(.title2)
+                        .foregroundStyle(serviceType.color)
+                }
+                VStack(alignment: .leading, spacing: 4) {
+                    Text("Add \(serviceType.rawValue) Device")
+                        .font(.title2.bold())
+                    Text("Enter device details manually")
+                        .font(.caption)
+                        .foregroundStyle(.secondary)
+                }
+                Spacer()
+                Button(action: { dismiss() }) {
+                    Image(systemName: "xmark.circle.fill")
+                        .font(.title2)
+                        .foregroundStyle(.secondary)
+                }
+                .buttonStyle(.plain)
+            }
+            .padding()
+            .background(Color.gray.opacity(0.1))
+            
+            Divider()
+            
+            // FORM - –ü–æ–ª—è –≤–≤–æ–¥–∞ (–¢–û–õ–¨–ö–û –∏–º—è –∏ IP, –ë–ï–ó MAC)
+            VStack(alignment: .leading, spacing: 16) {
+                // –ü–æ–ª–µ: –ò–º—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ (–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ)
+                VStack(alignment: .leading, spacing: 8) {
+                    Label("Device Name", systemImage: "tag")
+                        .font(.headline)
+                    TextField("Enter device name", text: $deviceName)
+                        .textFieldStyle(.roundedBorder)
+                }
+                
+                // –ü–æ–ª–µ: IP –∞–¥—Ä–µ—Å (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ)
+                VStack(alignment: .leading, spacing: 8) {
+                    Label("IP Address", systemImage: "network")
+                        .font(.headline)
+                    TextField("192.168.1.100", text: $ipAddress)
+                        .textFieldStyle(.roundedBorder)
+                }
+                
+                // –°–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ (–µ—Å–ª–∏ IP –Ω–µ–≤–µ—Ä–Ω—ã–π)
+                if showError {
+                    HStack {
+                        Image(systemName: "exclamationmark.triangle.fill")
+                            .foregroundStyle(.red)
+                        Text(errorMessage)
+                            .font(.caption)
+                            .foregroundStyle(.red)
+                    }
+                    .padding(8)
+                    .background(Color.red.opacity(0.1))
+                    .cornerRadius(8)
+                }
+            }
+            .padding()
+            
+            Spacer()
+            
+            // BUTTONS - –ö–Ω–æ–ø–∫–∏ "Cancel" –∏ "Add Device"
+            HStack(spacing: 12) {
+                Button("Cancel") {
+                    dismiss()
+                }
+                .buttonStyle(.bordered)
+                
+                Button("Add Device") {
+                    if validateInput() {
+                        // –°–æ–∑–¥–∞–µ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –ë–ï–ó MAC –∞–¥—Ä–µ—Å–∞
+                        let newDevice = Device(
+                            name: deviceName.isEmpty ? "Manual Device" : deviceName,
+                            ip: ipAddress,
+                            mac: nil, // –ë–ï–ó MAC!
+                            type: "Manual",
+                            lastSeen: Date(),
+                            availableServices: [serviceType]
+                        )
+                        onAdd(newDevice)
+                    }
+                }
+                .buttonStyle(.borderedProminent)
+                .tint(serviceType.color)
+                .disabled(ipAddress.isEmpty)
+            }
+            .padding()
+        }
+        .frame(width: 500, height: 400)
+    }
+    
+    // VALIDATION - –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç–∏ IP –∞–¥—Ä–µ—Å–∞
+    // –§–æ—Ä–º–∞—Ç: xxx.xxx.xxx.xxx, –≥–¥–µ –∫–∞–∂–¥–æ–µ xxx –æ—Ç 0 –¥–æ 255
+    private func validateInput() -> Bool {
+        let parts = ipAddress.split(separator: ".")
+        guard parts.count == 4 else {
+            errorMessage = "Invalid IP address format"
+            showError = true
+            return false
+        }
+        
+        for part in parts {
+            guard let num = Int(part), num >= 0, num <= 255 else {
+                errorMessage = "Invalid IP address format"
+                showError = true
+                return false
+            }
+        }
+        
+        showError = false
+        return true
+    }
+}
diff --git a/Local Scope/Views/Components/ConnectionCard.swift b/Local Scope/Views/Components/ConnectionCard.swift
new file mode 100644
index 0000000..f9852be
--- /dev/null
+++ b/Local Scope/Views/Components/ConnectionCard.swift	
@@ -0,0 +1,80 @@
+//
+//  ConnectionCard.swift
+//  Local Scope
+//
+
+import SwiftUI
+
+struct ConnectionCard: View {
+    let device: Device
+    let serviceType: ServiceType
+    let onConnect: (Device, ServiceType) -> Void
+    
+    var body: some View {
+        HStack(spacing: 12) {
+            ZStack {
+                Circle()
+                    .fill(getDeviceColor(for: device.name).opacity(0.15))
+                    .frame(width: 50, height: 50)
+                Text(getDeviceEmoji(for: device.name))
+                    .font(.system(size: 24))
+            }
+            VStack(alignment: .leading, spacing: 4) {
+                Text(device.name)
+                    .font(.headline)
+                HStack(spacing: 6) {
+                    Image(systemName: "network")
+                        .font(.caption2)
+                        .foregroundStyle(.blue)
+                    Text(device.ip)
+                        .font(.system(size: 12, weight: .medium))
+                        .foregroundStyle(.blue)
+                }
+                if let mac = device.mac {
+                    HStack(spacing: 6) {
+                        Image(systemName: "barcode")
+                            .font(.caption2)
+                            .foregroundStyle(.secondary)
+                        Text(mac)
+                            .font(.system(size: 11, design: .monospaced))
+                            .foregroundStyle(.secondary)
+                    }
+                }
+            }
+            Spacer()
+            Button(action: { onConnect(device, serviceType) }) {
+                HStack(spacing: 4) {
+                    Image(systemName: "arrow.right.circle.fill")
+                    Text("Connect")
+                        .fontWeight(.semibold)
+                }
+                .font(.caption)
+                .foregroundStyle(.white)
+                .padding(.horizontal, 12)
+                .padding(.vertical, 6)
+                .background(serviceType.color)
+                .cornerRadius(8)
+            }
+            .buttonStyle(.plain)
+        }
+        .padding()
+        .background(RoundedRectangle(cornerRadius: 12).fill(Color.gray.opacity(0.05)))
+        .overlay(RoundedRectangle(cornerRadius: 12).stroke(serviceType.color.opacity(0.2), lineWidth: 1))
+    }
+    
+    private func getDeviceColor(for name: String) -> Color {
+        if name.contains("Router") { return .orange }
+        if name.contains("Apple") { return .gray }
+        if name.contains("Android") { return .green }
+        if name.contains("Smart TV") { return .purple }
+        return .blue
+    }
+    
+    private func getDeviceEmoji(for name: String) -> String {
+        if name.contains("Router") { return "üåê" }
+        if name.contains("Apple") { return "üì±" }
+        if name.contains("Android") { return "üì±" }
+        if name.contains("Smart TV") { return "üì∫" }
+        return "üíª"
+    }
+}
diff --git a/Local Scope/Views/Components/ConnectionSelectionSheet.swift b/Local Scope/Views/Components/ConnectionSelectionSheet.swift
new file mode 100644
index 0000000..70ef7b0
--- /dev/null
+++ b/Local Scope/Views/Components/ConnectionSelectionSheet.swift	
@@ -0,0 +1,96 @@
+//
+//  ConnectionSelectionSheet.swift
+//  Local Scope
+//
+//  –û–ö–ù–û –í–´–ë–û–†–ê –°–ï–†–í–ò–°–ê (–ø—Ä–∏ –¥–≤–æ–π–Ω–æ–º –∫–ª–∏–∫–µ)
+//
+
+import SwiftUI
+
+struct ConnectionSelectionSheet: View {
+    let device: Device
+    let onConnect: (Device, ServiceType) -> Void
+    @Environment(\.dismiss) var dismiss
+    
+    var body: some View {
+        VStack(spacing: 0) {
+            // HEADER
+            HStack(spacing: 12) {
+                Text(getDeviceEmoji(for: device.name))
+                    .font(.system(size: 40))
+                VStack(alignment: .leading, spacing: 4) {
+                    Text(device.name)
+                        .font(.title2.bold())
+                    Text(device.ip)
+                        .font(.subheadline)
+                        .foregroundStyle(.blue)
+                    if let mac = device.mac {
+                        Text(mac)
+                            .font(.caption)
+                            .foregroundStyle(.secondary)
+                    }
+                }
+                Spacer()
+                Button(action: { dismiss() }) {
+                    Image(systemName: "xmark.circle.fill")
+                        .font(.title2)
+                        .foregroundStyle(.secondary)
+                }
+                .buttonStyle(.plain)
+            }
+            .padding()
+            .background(Color.gray.opacity(0.1))
+            
+            Divider()
+            
+            // –°–ü–ò–°–û–ö –°–ï–†–í–ò–°–û–í
+            if device.availableServices.isEmpty {
+                // –ù–ï–¢ –°–ï–†–í–ò–°–û–í
+                Spacer()
+                VStack(spacing: 16) {
+                    Image(systemName: "wifi.slash")
+                        .font(.system(size: 48))
+                        .foregroundStyle(.secondary)
+                    Text("No services detected")
+                        .font(.headline)
+                        .foregroundStyle(.secondary)
+                    Text("This device doesn't have any open ports")
+                        .font(.caption)
+                        .foregroundStyle(.tertiary)
+                }
+                Spacer()
+            } else {
+                // –ï–°–¢–¨ –°–ï–†–í–ò–°–´
+                ScrollView {
+                    VStack(spacing: 16) {
+                        Text("Available Services")
+                            .font(.headline)
+                            .frame(maxWidth: .infinity, alignment: .leading)
+                        
+                        VStack(spacing: 12) {
+                            ForEach(device.availableServices, id: \.self) { service in
+                                ServiceButton(service: service) {
+                                    dismiss()
+                                    onConnect(device, service)
+                                }
+                            }
+                        }
+                    }
+                    .padding()
+                }
+                .frame(maxHeight: .infinity)
+            }
+        }
+        .frame(width: 500, height: 450)
+    }
+    
+    private func getDeviceEmoji(for name: String) -> String {
+        if name.contains("Router") { return "üåê" }
+        if name.contains("Apple") { return "üì±" }
+        if name.contains("Android") { return "üì±" }
+        if name.contains("Smart TV") { return "üì∫" }
+        if name.contains("Raspberry") { return "üçì" }
+        if name.contains("NAS") { return "üíæ" }
+        return "üíª"
+    }
+}
diff --git a/Local Scope/Views/Components/DeviceNode.swift b/Local Scope/Views/Components/DeviceNode.swift
new file mode 100644
index 0000000..85833ae
--- /dev/null
+++ b/Local Scope/Views/Components/DeviceNode.swift	
@@ -0,0 +1,100 @@
+//
+//  DeviceNode.swift
+//  Local Scope
+//
+//  –û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç —É–∑–µ–ª —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –Ω–∞ –∫–∞—Ä—Ç–µ —Å–µ—Ç–∏
+//  - –ò–∫–æ–Ω–∫–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ (üì±, üíª, üåê –∏ —Ç.–¥.)
+//  - –ù–∞–∑–≤–∞–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
+//  - IP –∞–¥—Ä–µ—Å
+//  - MAC –∞–¥—Ä–µ—Å (–µ—Å–ª–∏ –µ—Å—Ç—å)
+//  - –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ (—Ü–≤–µ—Ç–Ω—ã–µ —Ç–æ—á–∫–∏)
+//
+
+import SwiftUI
+
+struct DeviceNode: View {
+    let device: Device
+    
+    var body: some View {
+        VStack(spacing: 2) {
+            // –≠–º–æ–¥–∑–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ (üì±, üíª –∏ —Ç.–¥.)
+            Text(getDeviceEmoji(for: device.name))
+                .font(.system(size: 20))
+            
+            // –ù–∞–∑–≤–∞–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ (–±–µ–∑ —ç–º–æ–¥–∑–∏)
+            Text(cleanDeviceName(device.name))
+                .font(.system(size: 8, weight: .semibold))
+                .lineLimit(1)
+            
+            // IP –∞–¥—Ä–µ—Å (—Å–∏–Ω–∏–π —Ü–≤–µ—Ç)
+            Text(device.ip)
+                .font(.system(size: 7))
+                .foregroundStyle(.blue)
+            
+            // MAC –∞–¥—Ä–µ—Å (—Å–µ—Ä—ã–π, –µ—Å–ª–∏ –µ—Å—Ç—å)
+            if let mac = device.mac {
+                Text(mac)
+                    .font(.system(size: 6, design: .monospaced))
+                    .foregroundStyle(.secondary)
+                    .lineLimit(1)
+            }
+            
+            // –¶–≤–µ—Ç–Ω—ã–µ —Ç–æ—á–∫–∏ - –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
+            if !device.availableServices.isEmpty {
+                HStack(spacing: 2) {
+                    ForEach(device.availableServices, id: \.self) { service in
+                        Circle()
+                            .fill(service.color)
+                            .frame(width: 4, height: 4)
+                    }
+                }
+            }
+        }
+        .frame(width: 110, height: 85)
+        .background(getDeviceColor(for: device.name).opacity(0.15))
+        .cornerRadius(12)
+        .overlay(
+            RoundedRectangle(cornerRadius: 12)
+                .stroke(getDeviceColor(for: device.name).opacity(0.7), lineWidth: 2)
+        )
+        .shadow(color: .black.opacity(0.1), radius: 3)
+    }
+    
+    // –£–±–∏—Ä–∞–µ—Ç —ç–º–æ–¥–∑–∏ –∏–∑ –Ω–∞–∑–≤–∞–Ω–∏—è
+    private func cleanDeviceName(_ name: String) -> String {
+        name.replacingOccurrences(of: "üåê ", with: "")
+            .replacingOccurrences(of: "üì± ", with: "")
+            .replacingOccurrences(of: "üì∫ ", with: "")
+            .replacingOccurrences(of: "üß∫ ", with: "")
+            .replacingOccurrences(of: "üè† ", with: "")
+            .replacingOccurrences(of: "üéÆ ", with: "")
+            .replacingOccurrences(of: "üñ•Ô∏è ", with: "")
+            .replacingOccurrences(of: "üçì ", with: "")
+            .replacingOccurrences(of: "üíæ ", with: "")
+            .replacingOccurrences(of: "üñ®Ô∏è ", with: "")
+            .replacingOccurrences(of: "üíª ", with: "")
+            .replacingOccurrences(of: "‚ùì ", with: "")
+    }
+    
+    // –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ü–≤–µ—Ç —Ä–∞–º–∫–∏ –ø–æ —Ç–∏–ø—É —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
+    private func getDeviceColor(for name: String) -> Color {
+        if name.contains("Router") { return .orange }
+        if name.contains("Apple") { return .gray }
+        if name.contains("Android") { return .green }
+        if name.contains("Smart TV") { return .purple }
+        if name.contains("Raspberry") { return .pink }
+        if name.contains("NAS") { return .indigo }
+        return .blue
+    }
+    
+    // –û–ø—Ä–µ–¥–µ–ª—è–µ—Ç —ç–º–æ–¥–∑–∏ –ø–æ —Ç–∏–ø—É —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
+    private func getDeviceEmoji(for name: String) -> String {
+        if name.contains("Router") { return "üåê" }
+        if name.contains("Apple") { return "üì±" }
+        if name.contains("Android") { return "üì±" }
+        if name.contains("Smart TV") { return "üì∫" }
+        if name.contains("Raspberry") { return "üçì" }
+        if name.contains("NAS") { return "üíæ" }
+        return "üíª"
+    }
+}
diff --git a/Local Scope/Views/Components/FTPFileManagerView.swift b/Local Scope/Views/Components/FTPFileManagerView.swift
new file mode 100644
index 0000000..190d8df
--- /dev/null
+++ b/Local Scope/Views/Components/FTPFileManagerView.swift	
@@ -0,0 +1,341 @@
+//
+//  FTPFileManagerView.swift
+//  Local Scope
+//
+//  –î–í–£–•–ü–ê–ù–ï–õ–¨–ù–´–ô –§–ê–ô–õ–û–í–´–ô –ú–ï–ù–ï–î–ñ–ï–†
+//  - –õ–µ–≤–∞—è –ø–∞–Ω–µ–ª—å: –õ–æ–∫–∞–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã (–≤–∞—à Mac)
+//  - –ü—Ä–∞–≤–∞—è –ø–∞–Ω–µ–ª—å: –£–¥–∞–ª—ë–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã (FTP/SFTP —Å–µ—Ä–≤–µ—Ä)
+//  - –û–ø–µ—Ä–∞—Ü–∏–∏: –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å, –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å, —É–¥–∞–ª–∏—Ç—å, –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å
+//
+
+import SwiftUI
+
+struct FTPFileManagerView: View {
+    let device: Device
+    let serviceType: ServiceType
+    @Environment(\.dismiss) var dismiss
+    
+    @State private var localPath: String = NSHomeDirectory()
+    @State private var remotePath: String = "/"
+    @State private var localFiles: [FileItem] = []
+    @State private var remoteFiles: [FileItem] = []
+    @State private var selectedLocalFiles: Set<String> = []
+    @State private var selectedRemoteFiles: Set<String> = []
+    @State private var connectionStatus: String = "Connecting..."
+    @State private var isConnected: Bool = false
+    
+    private let ftpManager = FTPManager()
+    
+    var body: some View {
+        VStack(spacing: 0) {
+            // HEADER
+            HStack {
+                Image(systemName: serviceType.icon)
+                    .foregroundStyle(serviceType.color)
+                VStack(alignment: .leading, spacing: 2) {
+                    Text("\(serviceType.rawValue) File Manager - \(device.name)")
+                        .font(.headline)
+                    Text(device.ip)
+                        .font(.caption)
+                        .foregroundStyle(.secondary)
+                }
+                Spacer()
+                Circle()
+                    .fill(isConnected ? Color.green : Color.orange)
+                    .frame(width: 8, height: 8)
+                Text(connectionStatus)
+                    .font(.caption)
+                    .foregroundStyle(.secondary)
+                Button(action: { disconnect() }) {
+                    Image(systemName: "xmark.circle.fill")
+                        .foregroundStyle(.secondary)
+                }
+                .buttonStyle(.plain)
+            }
+            .padding()
+            .background(Color.gray.opacity(0.1))
+            
+            Divider()
+            
+            // –î–í–£–•–ü–ê–ù–ï–õ–¨–ù–´–ô –ò–ù–¢–ï–†–§–ï–ô–°
+            HSplitView {
+                // –õ–ï–í–ê–Ø –ü–ê–ù–ï–õ–¨ - –õ–æ–∫–∞–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã
+                FilePanel(
+                    title: "Local Files",
+                    path: $localPath,
+                    files: $localFiles,
+                    selectedFiles: $selectedLocalFiles,
+                    onRefresh: loadLocalFiles,
+                    onNavigate: { path in
+                        localPath = path
+                        loadLocalFiles()
+                    },
+                    isLocal: true
+                )
+                
+                // –ü–†–ê–í–ê–Ø –ü–ê–ù–ï–õ–¨ - –£–¥–∞–ª—ë–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
+                FilePanel(
+                    title: "Remote Files (\(device.ip))",
+                    path: $remotePath,
+                    files: $remoteFiles,
+                    selectedFiles: $selectedRemoteFiles,
+                    onRefresh: loadRemoteFiles,
+                    onNavigate: { path in
+                        remotePath = path
+                        loadRemoteFiles()
+                    },
+                    isLocal: false
+                )
+            }
+            
+            Divider()
+            
+            // –ü–ê–ù–ï–õ–¨ –ò–ù–°–¢–†–£–ú–ï–ù–¢–û–í
+            HStack(spacing: 12) {
+                ToolButton(icon: "arrow.right", title: "Copy ‚Üí", color: .blue) {
+                    copyToRemote()
+                }
+                .disabled(selectedLocalFiles.isEmpty)
+                
+                ToolButton(icon: "arrow.left", title: "‚Üê Copy", color: .blue) {
+                    copyToLocal()
+                }
+                .disabled(selectedRemoteFiles.isEmpty)
+                
+                Spacer()
+                
+                ToolButton(icon: "trash", title: "Delete", color: .red) {
+                    deleteSelected()
+                }
+                .disabled(selectedLocalFiles.isEmpty && selectedRemoteFiles.isEmpty)
+                
+                ToolButton(icon: "pencil", title: "Rename", color: .orange) {
+                    renameSelected()
+                }
+                .disabled(selectedLocalFiles.count + selectedRemoteFiles.count != 1)
+            }
+            .padding()
+            .background(Color.gray.opacity(0.05))
+        }
+        .frame(minWidth: 1000, minHeight: 700)
+        .onAppear {
+            connect()
+        }
+    }
+    
+    // MARK: - Connection
+    private func connect() {
+        Task {
+            connectionStatus = "Connecting..."
+            let result = await ftpManager.connect(to: device.ip, type: serviceType)
+            
+            await MainActor.run {
+                if result.success {
+                    isConnected = true
+                    connectionStatus = "Connected"
+                    loadLocalFiles()
+                    loadRemoteFiles()
+                } else {
+                    connectionStatus = "Connection failed"
+                }
+            }
+        }
+    }
+    
+    private func disconnect() {
+        ftpManager.disconnect()
+        dismiss()
+    }
+    
+    // MARK: - Load Files
+    private func loadLocalFiles() {
+        Task {
+            let files = await ftpManager.listLocalFiles(at: localPath)
+            await MainActor.run {
+                localFiles = files
+            }
+        }
+    }
+    
+    private func loadRemoteFiles() {
+        Task {
+            let files = await ftpManager.listRemoteFiles(at: remotePath)
+            await MainActor.run {
+                remoteFiles = files
+            }
+        }
+    }
+    
+    // MARK: - File Operations
+    private func copyToRemote() {
+        Task {
+            for file in selectedLocalFiles {
+                await ftpManager.upload(localPath: file, remotePath: remotePath)
+            }
+            selectedLocalFiles.removeAll()
+            loadRemoteFiles()
+        }
+    }
+    
+    private func copyToLocal() {
+        Task {
+            for file in selectedRemoteFiles {
+                await ftpManager.download(remotePath: file, localPath: localPath)
+            }
+            selectedRemoteFiles.removeAll()
+            loadLocalFiles()
+        }
+    }
+    
+    private func deleteSelected() {
+        // Implementation
+    }
+    
+    private func renameSelected() {
+        // Implementation
+    }
+}
+
+// MARK: - File Panel
+struct FilePanel: View {
+    let title: String
+    @Binding var path: String
+    @Binding var files: [FileItem]
+    @Binding var selectedFiles: Set<String>
+    let onRefresh: () -> Void
+    let onNavigate: (String) -> Void
+    let isLocal: Bool
+    
+    var body: some View {
+        VStack(spacing: 0) {
+            // Path bar
+            HStack {
+                Text(title)
+                    .font(.headline)
+                Spacer()
+                TextField("Path", text: $path)
+                    .textFieldStyle(.roundedBorder)
+                    .frame(maxWidth: 300)
+                Button(action: onRefresh) {
+                    Image(systemName: "arrow.clockwise")
+                }
+                .buttonStyle(.plain)
+            }
+            .padding()
+            
+            Divider()
+            
+            // File list
+            List(files, selection: $selectedFiles) { file in
+                FileRow(file: file, onDoubleClick: {
+                    if file.isDirectory {
+                        onNavigate(file.path)
+                    }
+                })
+            }
+        }
+    }
+}
+
+// MARK: - File Row
+struct FileRow: View {
+    let file: FileItem
+    let onDoubleClick: () -> Void
+    
+    var body: some View {
+        HStack {
+            Image(systemName: file.isDirectory ? "folder.fill" : "doc.fill")
+                .foregroundStyle(file.isDirectory ? .blue : .gray)
+            Text(file.name)
+            Spacer()
+            if !file.isDirectory {
+                Text(formatFileSize(file.size))
+                    .font(.caption)
+                    .foregroundStyle(.secondary)
+            }
+        }
+        .contentShape(Rectangle())
+        .onTapGesture(count: 2) {
+            onDoubleClick()
+        }
+    }
+    
+    private func formatFileSize(_ size: Int64) -> String {
+        let formatter = ByteCountFormatter()
+        formatter.allowedUnits = [.useKB, .useMB, .useGB]
+        formatter.countStyle = .file
+        return formatter.string(fromByteCount: size)
+    }
+}
+
+// MARK: - Tool Button
+struct ToolButton: View {
+    let icon: String
+    let title: String
+    let color: Color
+    let action: () -> Void
+    
+    var body: some View {
+        Button(action: action) {
+            HStack {
+                Image(systemName: icon)
+                Text(title)
+            }
+            .padding(.horizontal, 12)
+            .padding(.vertical, 6)
+        }
+        .buttonStyle(.bordered)
+        .tint(color)
+    }
+}
+
+// MARK: - Models
+struct FileItem: Identifiable {
+    let id = UUID()
+    let name: String
+    let path: String
+    let size: Int64
+    let isDirectory: Bool
+}
+
+// MARK: - FTP Manager
+actor FTPManager {
+    func connect(to ip: String, type: ServiceType) async -> (success: Bool, message: String) {
+        // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
+        try? await Task.sleep(nanoseconds: 1_000_000_000)
+        return (true, "Connected")
+    }
+    
+    func disconnect() {
+        // –û—Ç–∫–ª—é—á–µ–Ω–∏–µ
+    }
+    
+    func listLocalFiles(at path: String) async -> [FileItem] {
+        do {
+            let items = try FileManager.default.contentsOfDirectory(atPath: path)
+            return items.map { name in
+                let fullPath = (path as NSString).appendingPathComponent(name)
+                var isDir: ObjCBool = false
+                FileManager.default.fileExists(atPath: fullPath, isDirectory: &isDir)
+                let attrs = try? FileManager.default.attributesOfItem(atPath: fullPath)
+                let size = attrs?[.size] as? Int64 ?? 0
+                return FileItem(name: name, path: fullPath, size: size, isDirectory: isDir.boolValue)
+            }
+        } catch {
+            return []
+        }
+    }
+    
+    func listRemoteFiles(at path: String) async -> [FileItem] {
+        // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ SSH/SFTP
+        return []
+    }
+    
+    func upload(localPath: String, remotePath: String) async {
+        // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≥—Ä—É–∑–∫–∏
+    }
+    
+    func download(remotePath: String, localPath: String) async {
+        // –†–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è
+    }
+}
diff --git a/Local Scope/Views/Components/InteractiveNetworkCanvas.swift b/Local Scope/Views/Components/InteractiveNetworkCanvas.swift
new file mode 100644
index 0000000..a79b6fb
--- /dev/null
+++ b/Local Scope/Views/Components/InteractiveNetworkCanvas.swift	
@@ -0,0 +1,107 @@
+//
+//  InteractiveNetworkCanvas.swift
+//  Local Scope
+//
+//  –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–∞—è –∫–∞—Ä—Ç–∞ —Å–µ—Ç–∏ —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–º –º–µ–Ω—é
+//
+
+import SwiftUI
+
+struct InteractiveNetworkCanvas: View {
+    let devices: [Device]
+    let localIP: String
+    let onDeviceSelect: (Device) -> Void
+    let onDeviceConnect: ((Device, ServiceType) -> Void)?
+    let onAddToFavorites: ((Device, ServiceType) -> Void)?
+    
+    var body: some View {
+        GeometryReader { geometry in
+            let center = CGPoint(x: geometry.size.width / 2, y: geometry.size.height / 2)
+            let radius = min(geometry.size.width, geometry.size.height) / 3
+            let visibleDevices = Array(devices.prefix(16))
+            
+            ZStack {
+                // –§–æ–Ω–æ–≤–∞—è —Å–µ—Ç–∫–∞
+                Canvas { context, size in
+                    drawBackground(context: context, size: size, center: center, radius: radius, deviceCount: visibleDevices.count)
+                }
+                
+                // –£—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
+                ForEach(visibleDevices.indices, id: \.self) { index in
+                    let device = visibleDevices[index]
+                    let position = calculatePosition(index: index, total: visibleDevices.count, center: center, radius: radius)
+                    
+                    DeviceNode(device: device)
+                        .position(position)
+                        .onTapGesture(count: 2) {
+                            onDeviceSelect(device)
+                        }
+                        .contextMenu {
+                            // –ö–û–ù–¢–ï–ö–°–¢–ù–û–ï –ú–ï–ù–Æ (–≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–µ)
+                            if device.availableServices.isEmpty {
+                                Text("No services available")
+                                    .foregroundStyle(.secondary)
+                            } else {
+                                // –°–µ–∫—Ü–∏—è: –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ
+                                ForEach(device.availableServices, id: \.self) { service in
+                                    Button {
+                                        onDeviceConnect?(device, service)
+                                    } label: {
+                                        Label("Connect via \(service.rawValue)", systemImage: service.icon)
+                                    }
+                                }
+                                
+                                Divider()
+                                
+                                // –°–µ–∫—Ü–∏—è: –ò–∑–±—Ä–∞–Ω–Ω–æ–µ
+                                ForEach(device.availableServices, id: \.self) { service in
+                                    Button {
+                                        onAddToFavorites?(device, service)
+                                    } label: {
+                                        HStack {
+                                            Image(systemName: device.favoriteServices.contains(service) ? "star.fill" : "star")
+                                            Text("Add \(service.rawValue) to favorites")
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                }
+            }
+        }
+    }
+    
+    // MARK: - Drawing Functions
+    private func drawBackground(context: GraphicsContext, size: CGSize, center: CGPoint, radius: CGFloat, deviceCount: Int) {
+        // –ü—É–ª—å—Å–∏—Ä—É—é—â–∏–µ –∫—Ä—É–≥–∏
+        for i in 1...3 {
+            let pulseRadius = CGFloat(i) * 20
+            let circle = Path { p in
+                p.addEllipse(in: CGRect(x: center.x - pulseRadius, y: center.y - pulseRadius, width: pulseRadius * 2, height: pulseRadius * 2))
+            }
+            context.stroke(circle, with: .color(.blue.opacity(0.15 - Double(i) * 0.04)), lineWidth: 1.5)
+        }
+        
+        // –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π Mac
+        let centerRect = CGRect(x: center.x - 50, y: center.y - 30, width: 100, height: 60)
+        context.fill(Path(roundedRect: centerRect, cornerRadius: 12), with: .color(.blue.opacity(0.2)))
+        context.stroke(Path(roundedRect: centerRect, cornerRadius: 12), with: .color(.blue.opacity(0.6)), lineWidth: 2.5)
+        context.draw(Text("üíª").font(.system(size: 24)), at: CGPoint(x: center.x, y: center.y - 8))
+        context.draw(Text(localIP).font(.system(size: 10, weight: .bold)).foregroundStyle(.blue), at: CGPoint(x: center.x, y: center.y + 12))
+        
+        // –õ–∏–Ω–∏–∏ –∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º
+        for index in 0..<deviceCount {
+            let angle = Double(index) / Double(deviceCount) * 2 * .pi - .pi / 2
+            let endPoint = CGPoint(x: center.x + CGFloat(cos(angle)) * radius, y: center.y + CGFloat(sin(angle)) * radius)
+            var linePath = Path()
+            linePath.move(to: center)
+            linePath.addLine(to: endPoint)
+            context.stroke(linePath, with: .color(.green.opacity(0.4)), style: StrokeStyle(lineWidth: 2, lineCap: .round, dash: [5, 3]))
+        }
+    }
+    
+    private func calculatePosition(index: Int, total: Int, center: CGPoint, radius: CGFloat) -> CGPoint {
+        let angle = Double(index) / Double(total) * 2 * .pi - .pi / 2
+        return CGPoint(x: center.x + CGFloat(cos(angle)) * radius, y: center.y + CGFloat(sin(angle)) * radius)
+    }
+}
diff --git a/Local Scope/Views/Components/SSHTerminalView.swift b/Local Scope/Views/Components/SSHTerminalView.swift
new file mode 100644
index 0000000..7b1b7c9
--- /dev/null
+++ b/Local Scope/Views/Components/SSHTerminalView.swift	
@@ -0,0 +1,209 @@
+//
+//  SSHTerminalView.swift
+//  Local Scope
+//
+//  –í–°–¢–†–û–ï–ù–ù–´–ô SSH –¢–ï–†–ú–ò–ù–ê–õ
+//  - –ü–æ–¥–∫–ª—é—á–∞–µ—Ç—Å—è –∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤—É —á–µ—Ä–µ–∑ SSH
+//  - –≠–º—É–ª–∏—Ä—É–µ—Ç —Ç–µ—Ä–º–∏–Ω–∞–ª (—á–µ—Ä–Ω—ã–π —ç–∫—Ä–∞–Ω, –∑–µ–ª–µ–Ω—ã–π —Ç–µ–∫—Å—Ç)
+//  - –ö–æ–º–∞–Ω–¥—ã –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è —á–µ—Ä–µ–∑ Process + ssh
+//
+
+import SwiftUI
+
+struct SSHTerminalView: View {
+    let device: Device
+    @Environment(\.dismiss) var dismiss
+    
+    @State private var output: String = ""
+    @State private var command: String = ""
+    @State private var isConnected: Bool = false
+    @State private var connectionStatus: String = "Connecting..."
+    
+    private let sshProcess = SSHProcess()
+    
+    var body: some View {
+        VStack(spacing: 0) {
+            // HEADER - –ó–∞–≥–æ–ª–æ–≤–æ–∫ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ
+            HStack {
+                Image(systemName: "terminal.fill")
+                    .foregroundStyle(.green)
+                VStack(alignment: .leading, spacing: 2) {
+                    Text("SSH Terminal - \(device.name)")
+                        .font(.headline)
+                    Text(device.ip)
+                        .font(.caption)
+                        .foregroundStyle(.secondary)
+                }
+                Spacer()
+                Circle()
+                    .fill(isConnected ? Color.green : Color.orange)
+                    .frame(width: 8, height: 8)
+                Text(connectionStatus)
+                    .font(.caption)
+                    .foregroundStyle(.secondary)
+                Button(action: { disconnect() }) {
+                    Image(systemName: "xmark.circle.fill")
+                        .foregroundStyle(.secondary)
+                }
+                .buttonStyle(.plain)
+            }
+            .padding()
+            .background(Color.gray.opacity(0.1))
+            
+            Divider()
+            
+            // TERMINAL OUTPUT - –í—ã–≤–æ–¥ —Ç–µ—Ä–º–∏–Ω–∞–ª–∞
+            ScrollView {
+                ScrollViewReader { proxy in
+                    Text(output)
+                        .font(.system(size: 12, design: .monospaced))
+                        .foregroundStyle(.green)
+                        .frame(maxWidth: .infinity, alignment: .leading)
+                        .padding()
+                        .id("bottom")
+                        .onChange(of: output) { _ in
+                            proxy.scrollTo("bottom", anchor: .bottom)
+                        }
+                }
+            }
+            .background(Color.black)
+            
+            Divider()
+            
+            // COMMAND INPUT - –ü–æ–ª–µ –≤–≤–æ–¥–∞ –∫–æ–º–∞–Ω–¥
+            HStack {
+                Text("$")
+                    .font(.system(size: 14, design: .monospaced))
+                    .foregroundStyle(.green)
+                TextField("Enter command...", text: $command)
+                    .textFieldStyle(.plain)
+                    .font(.system(size: 14, design: .monospaced))
+                    .foregroundStyle(.green)
+                    .onSubmit {
+                        executeCommand()
+                    }
+                Button(action: executeCommand) {
+                    Image(systemName: "arrow.right.circle.fill")
+                        .foregroundStyle(.green)
+                }
+                .buttonStyle(.plain)
+                .disabled(!isConnected)
+            }
+            .padding()
+            .background(Color.black)
+        }
+        .frame(width: 800, height: 600)
+        .onAppear {
+            connect()
+        }
+        .onDisappear {
+            disconnect()
+        }
+    }
+    
+    // MARK: - SSH Connection
+    private func connect() {
+        Task {
+            connectionStatus = "Connecting..."
+            output += "Connecting to \(device.ip)...\n"
+            
+            let result = await sshProcess.connect(to: device.ip)
+            
+            await MainActor.run {
+                if result.success {
+                    isConnected = true
+                    connectionStatus = "Connected"
+                    output += result.message + "\n"
+                    output += "Type commands below:\n\n"
+                } else {
+                    connectionStatus = "Connection failed"
+                    output += "Error: \(result.message)\n"
+                }
+            }
+        }
+    }
+    
+    // MARK: - Execute Command
+    private func executeCommand() {
+        guard !command.isEmpty else { return }
+        
+        output += "$ \(command)\n"
+        let cmd = command
+        command = ""
+        
+        Task {
+            let result = await sshProcess.execute(cmd)
+            await MainActor.run {
+                output += result + "\n"
+            }
+        }
+    }
+    
+    // MARK: - Disconnect
+    private func disconnect() {
+        sshProcess.disconnect()
+        dismiss()
+    }
+}
+
+// MARK: - SSH Process Handler
+actor SSHProcess {
+    private var process: Process?
+    private var inputPipe: Pipe?
+    private var outputPipe: Pipe?
+    
+    func connect(to ip: String) async -> (success: Bool, message: String) {
+        let newProcess = Process()
+        newProcess.executableURL = URL(fileURLWithPath: "/usr/bin/ssh")
+        newProcess.arguments = ["-o", "StrictHostKeyChecking=no", ip]
+        
+        let input = Pipe()
+        let output = Pipe()
+        
+        newProcess.standardInput = input
+        newProcess.standardOutput = output
+        newProcess.standardError = output
+        
+        do {
+            try newProcess.run()
+            self.process = newProcess
+            self.inputPipe = input
+            self.outputPipe = output
+            
+            return (true, "Connected to \(ip)")
+        } catch {
+            return (false, "Failed to connect: \(error.localizedDescription)")
+        }
+    }
+    
+    func execute(_ command: String) async -> String {
+        guard let input = inputPipe else {
+            return "Error: Not connected"
+        }
+        
+        let data = (command + "\n").data(using: .utf8)!
+        
+        do {
+            try input.fileHandleForWriting.write(contentsOf: data)
+            
+            // Wait a bit for output
+            try await Task.sleep(nanoseconds: 500_000_000) // 0.5 seconds
+            
+            guard let output = outputPipe else {
+                return ""
+            }
+            
+            let availableData = output.fileHandleForReading.availableData
+            return String(data: availableData, encoding: .utf8) ?? ""
+        } catch {
+            return "Error: \(error.localizedDescription)"
+        }
+    }
+    
+    func disconnect() {
+        process?.terminate()
+        process = nil
+        inputPipe = nil
+        outputPipe = nil
+    }
+}
diff --git a/Local Scope/Views/Components/ServiceButton.swift b/Local Scope/Views/Components/ServiceButton.swift
new file mode 100644
index 0000000..6d5ecd4
--- /dev/null
+++ b/Local Scope/Views/Components/ServiceButton.swift	
@@ -0,0 +1,43 @@
+//
+//  ServiceButton.swift
+//  Local Scope
+//
+
+import SwiftUI
+
+struct ServiceButton: View {
+    let service: ServiceType
+    let action: () -> Void
+    
+    var body: some View {
+        Button(action: action) {
+            HStack(spacing: 16) {
+                ZStack {
+                    Circle()
+                        .fill(service.color.opacity(0.2))
+                        .frame(width: 50, height: 50)
+                    Image(systemName: service.icon)
+                        .font(.title2)
+                        .foregroundStyle(service.color)
+                }
+                VStack(alignment: .leading, spacing: 4) {
+                    Text(service.rawValue)
+                        .font(.headline)
+                        .foregroundStyle(.primary)
+                    Text("Port \(service.port)")
+                        .font(.caption)
+                        .foregroundStyle(.secondary)
+                }
+                Spacer()
+                Image(systemName: "arrow.right.circle.fill")
+                    .font(.title3)
+                    .foregroundStyle(service.color)
+            }
+            .padding()
+            .frame(maxWidth: .infinity)
+            .background(RoundedRectangle(cornerRadius: 12).fill(Color.gray.opacity(0.05)))
+            .overlay(RoundedRectangle(cornerRadius: 12).stroke(service.color.opacity(0.3), lineWidth: 2))
+        }
+        .buttonStyle(.plain)
+    }
+}
diff --git a/Local Scope/Views/Components/SettingsButton.swift b/Local Scope/Views/Components/SettingsButton.swift
new file mode 100644
index 0000000..9058555
--- /dev/null
+++ b/Local Scope/Views/Components/SettingsButton.swift	
@@ -0,0 +1,42 @@
+//
+//  SettingsButton.swift
+//  Local Scope
+//
+
+import SwiftUI
+
+struct SettingsButton: View {
+    let icon: String
+    let title: String
+    let subtitle: String
+    let color: Color
+    let action: () -> Void
+    
+    var body: some View {
+        Button(action: action) {
+            HStack(spacing: 12) {
+                ZStack {
+                    Circle()
+                        .fill(color.opacity(0.15))
+                        .frame(width: 44, height: 44)
+                    Image(systemName: icon)
+                        .font(.system(size: 18))
+                        .foregroundStyle(color)
+                }
+                VStack(alignment: .leading, spacing: 2) {
+                    Text(title)
+                        .font(.headline)
+                        .foregroundStyle(.primary)
+                    Text(subtitle)
+                        .font(.caption)
+                        .foregroundStyle(.secondary)
+                }
+                Spacer()
+                Image(systemName: "chevron.right")
+                    .font(.caption)
+                    .foregroundStyle(.tertiary)
+            }
+        }
+        .buttonStyle(.plain)
+    }
+}
diff --git a/Local Scope/Views/ConnectionsView.swift b/Local Scope/Views/ConnectionsView.swift
new file mode 100644
index 0000000..ee432fd
--- /dev/null
+++ b/Local Scope/Views/ConnectionsView.swift	
@@ -0,0 +1,82 @@
+//
+//  ConnectionsView.swift
+//  Local Scope
+//
+//  –í–ö–õ–ê–î–ö–ò SSH/RDP/FTP
+//  - –§–∏–ª—å—Ç—Ä—É–µ—Ç —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –ø–æ —Ç–∏–ø—É —Å–µ—Ä–≤–∏—Å–∞
+//  - –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
+//  - –ö–Ω–æ–ø–∫–∞ "+" –¥–ª—è —Ä—É—á–Ω–æ–≥–æ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è
+//
+
+import SwiftUI
+
+struct ConnectionsView: View {
+    let devices: [Device]
+    let history: [Device]
+    let serviceType: ServiceType
+    let title: String
+    let onConnect: (Device, ServiceType) -> Void
+    let onAddManual: () -> Void
+    
+    var filteredDevices: [Device] {
+        let allDevices = devices + history
+        let grouped = Dictionary(grouping: allDevices, by: { $0.ip })
+        let unique = grouped.compactMap { $0.value.first }
+        let filtered = unique.filter { $0.availableServices.contains(serviceType) }
+        return filtered.sorted { $0.lastSeen > $1.lastSeen }
+    }
+    
+    var body: some View {
+        VStack {
+            HStack {
+                Image(systemName: serviceType.icon)
+                    .font(.title2)
+                    .foregroundStyle(serviceType.color)
+                Text(title)
+                    .font(.title2.bold())
+                Spacer()
+                Button(action: onAddManual) {
+                    Image(systemName: "plus.circle.fill")
+                        .font(.title3)
+                        .foregroundStyle(serviceType.color)
+                }
+                .buttonStyle(.plain)
+                .help("Add device manually")
+                Label("\(filteredDevices.count)", systemImage: "number")
+                    .font(.caption)
+                    .foregroundStyle(.secondary)
+                    .padding(.horizontal, 8)
+                    .padding(.vertical, 4)
+                    .background(serviceType.color.opacity(0.1))
+                    .cornerRadius(6)
+            }
+            .padding(.horizontal)
+            .padding(.top, 10)
+            
+            if filteredDevices.isEmpty {
+                Spacer()
+                VStack(spacing: 12) {
+                    Image(systemName: serviceType.icon)
+                        .font(.system(size: 48))
+                        .foregroundStyle(.secondary)
+                    Text("No \(serviceType.rawValue) devices found")
+                        .font(.headline)
+                        .foregroundStyle(.secondary)
+                    Text("Scan the network or add device manually")
+                        .font(.caption)
+                        .foregroundStyle(.tertiary)
+                }
+                Spacer()
+            } else {
+                ScrollView {
+                    LazyVStack(spacing: 12) {
+                        ForEach(filteredDevices) { device in
+                            ConnectionCard(device: device, serviceType: serviceType, onConnect: onConnect)
+                        }
+                    }
+                    .padding()
+                }
+            }
+        }
+    }
+}
diff --git a/Local Scope/Views/ContentView.swift b/Local Scope/Views/ContentView.swift
new file mode 100644
index 0000000..ac10860
--- /dev/null
+++ b/Local Scope/Views/ContentView.swift	
@@ -0,0 +1,312 @@
+//
+//  ContentView.swift
+//  Local Scope
+//
+
+import SwiftUI
+import Foundation
+
+struct ContentView: View {
+    @StateObject private var viewModel = NetworkScannerViewModel()
+    @State private var selectedTab = 0
+    @State private var selectedDevice: Device?
+    @State private var showConnectionSheet = false
+    @State private var showAddDeviceSheet = false
+    @State private var addDeviceServiceType: ServiceType = .ssh
+    
+    // SSH Terminal
+    @State private var showSSHTerminal = false
+    @State private var sshDevice: Device?
+    @State private var sshCredentials: ConnectionCredentials?
+    
+    // FTP/SFTP File Manager
+    @State private var showFileManager = false
+    @State private var ftpDevice: Device?
+    @State private var ftpServiceType: ServiceType = .ftp
+    @State private var ftpCredentials: ConnectionCredentials?
+    
+    // RDP
+    @State private var showRDP = false
+    @State private var rdpDevice: Device?
+    @State private var rdpCredentials: ConnectionCredentials?
+    
+    // Credentials Input
+    @State private var showCredentialsSheet = false
+    @State private var pendingConnection: (Device, ServiceType)?
+    
+    var body: some View {
+        VStack(spacing: 0) {
+            TabView(selection: $selectedTab) {
+                // MARK: - Network Map Tab
+                NetworkMapView(
+                    devices: $viewModel.devices,
+                    localIP: $viewModel.localIP,
+                    scanning: $viewModel.scanning,
+                    progress: $viewModel.progress,
+                    onScan: { viewModel.scanNetwork() },
+                    onDeviceSelect: { device in
+                        handleDeviceSelection(device)
+                    },
+                    onDeviceConnect: { device, service in
+                        handleConnection(device: device, service: service)
+                    },
+                    onAddToFavorites: { device, service in
+                        viewModel.toggleFavorite(device: device, service: service)
+                    }
+                )
+                .tabItem {
+                    Label("Network Map", systemImage: "network")
+                }
+                .tag(0)
+                
+                // MARK: - SSH Tab
+                ConnectionsView(
+                    devices: viewModel.devices,
+                    history: viewModel.history,
+                    serviceType: ServiceType.ssh,
+                    title: "SSH Connections",
+                    onConnect: { device, service in
+                        handleConnection(device: device, service: service)
+                    },
+                    onAddManual: {
+                        addDeviceServiceType = ServiceType.ssh
+                        showAddDeviceSheet = true
+                    }
+                )
+                .tabItem {
+                    Label("SSH", systemImage: "terminal")
+                }
+                .tag(1)
+                
+                // MARK: - RDP Tab
+                ConnectionsView(
+                    devices: viewModel.devices,
+                    history: viewModel.history,
+                    serviceType: ServiceType.rdp,
+                    title: "RDP Connections",
+                    onConnect: { device, service in
+                        handleConnection(device: device, service: service)
+                    },
+                    onAddManual: {
+                        addDeviceServiceType = ServiceType.rdp
+                        showAddDeviceSheet = true
+                    }
+                )
+                .tabItem {
+                    Label("RDP", systemImage: "desktopcomputer")
+                }
+                .tag(2)
+                
+                // MARK: - FTP Tab
+                ConnectionsView(
+                    devices: viewModel.devices,
+                    history: viewModel.history,
+                    serviceType: ServiceType.ftp,
+                    title: "FTP/SFTP Transfers",
+                    onConnect: { device, service in
+                        handleConnection(device: device, service: service)
+                    },
+                    onAddManual: {
+                        addDeviceServiceType = ServiceType.ftp
+                        showAddDeviceSheet = true
+                    }
+                )
+                .tabItem {
+                    Label("FTP", systemImage: "folder")
+                }
+                .tag(3)
+                
+                // MARK: - History Tab
+                HistoryView(
+                    history: viewModel.history,
+                    onConnect: { device, service in
+                        handleConnection(device: device, service: service)
+                    },
+                    onDelete: { device in
+                        viewModel.deleteFromHistory(device: device)
+                    }
+                )
+                .tabItem {
+                    Label("History", systemImage: "clock.arrow.circlepath")
+                }
+                .tag(4)
+                
+                // MARK: - Sessions Tab (–ù–û–í–ê–Ø –í–ö–õ–ê–î–ö–ê!)
+                SessionsView(
+                    sessions: viewModel.savedSessions,
+                    onConnect: { session in
+                        handleSessionConnect(session)
+                    },
+                    onDelete: { session in
+                        viewModel.deleteSession(session)
+                    }
+                )
+                .tabItem {
+                    Label("Sessions", systemImage: "bookmark.fill")
+                }
+                .tag(5)
+                
+                // MARK: - Settings Tab
+                SettingsView(
+                    onReload: { Task { await viewModel.loadHistory() } },
+                    onClear: { viewModel.clearHistory() }
+                )
+                .tabItem {
+                    Label("Settings", systemImage: "gear")
+                }
+                .tag(6)
+            }
+            
+            // MARK: - Status Bar
+            if !viewModel.syncStatus.isEmpty {
+                Text(viewModel.syncStatus)
+                    .font(.caption)
+                    .padding(8)
+                    .frame(maxWidth: .infinity)
+                    .background(
+                        viewModel.syncStatus.contains("‚úÖ") || viewModel.syncStatus.contains("‚≠ê")
+                        ? Color.green.opacity(0.2)
+                        : Color.red.opacity(0.2)
+                    )
+            }
+        }
+        .frame(minWidth: 900, minHeight: 650)
+        
+        // MARK: - Connection Selection Sheet
+        .sheet(isPresented: $showConnectionSheet) {
+            if let device = selectedDevice {
+                ConnectionSelectionSheet(
+                    device: device,
+                    onConnect: { dev, service in
+                        showConnectionSheet = false
+                        handleConnection(device: dev, service: service)
+                    }
+                )
+            }
+        }
+        
+        // MARK: - Add Device Sheet
+        .sheet(isPresented: $showAddDeviceSheet) {
+            AddDeviceSheet(
+                serviceType: addDeviceServiceType,
+                onAdd: { device in
+                    showAddDeviceSheet = false
+                    viewModel.addManualDevice(device)
+                }
+            )
+        }
+        
+        // MARK: - Credentials Input Sheet
+        .sheet(isPresented: $showCredentialsSheet) {
+            if let (device, service) = pendingConnection {
+                CredentialsInputSheet(
+                    device: device,
+                    serviceType: service,
+                    onConnect: { credentials in
+                        showCredentialsSheet = false
+                        performConnectionWithCredentials(device: device, service: service, credentials: credentials)
+                    }
+                )
+            }
+        }
+        
+        // MARK: - SSH Terminal Sheet
+        .sheet(isPresented: $showSSHTerminal) {
+            if let device = sshDevice {
+                SSHTerminalView(device: device, credentials: sshCredentials)
+            }
+        }
+        
+        // MARK: - FTP/SFTP File Manager Sheet
+        .sheet(isPresented: $showFileManager) {
+            if let device = ftpDevice {
+                FTPFileManagerView(device: device, serviceType: ftpServiceType, credentials: ftpCredentials)
+            }
+        }
+        
+        // MARK: - RDP Viewer Sheet (–ù–û–í–´–ô!)
+        .sheet(isPresented: $showRDP) {
+            if let device = rdpDevice {
+                RDPViewerView(device: device, credentials: rdpCredentials)
+            }
+        }
+    }
+    
+    // MARK: - Handle Device Selection
+    private func handleDeviceSelection(_ device: Device) {
+        // –ï—Å–ª–∏ —Ä–æ—É—Ç–µ—Ä - –æ—Ç–∫—Ä—ã—Ç—å –≤ –±—Ä–∞—É–∑–µ—Ä–µ
+        if device.name.contains("Router") {
+            if let url = URL(string: "http://\(device.ip)") {
+                NSWorkspace.shared.open(url)
+            }
+            return
+        }
+        
+        // –ò–Ω–∞—á–µ –ø–æ–∫–∞–∑–∞—Ç—å –æ–∫–Ω–æ –≤—ã–±–æ—Ä–∞
+        selectedDevice = device
+        showConnectionSheet = true
+    }
+    
+    // MARK: - Handle Connection
+    private func handleConnection(device: Device, service: ServiceType) {
+        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Å–æ—Ö—Ä–∞–Ω—ë–Ω–Ω—ã–µ credentials –¥–ª—è —ç—Ç–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
+        if let savedCreds = viewModel.getCredentials(for: device, service: service) {
+            performConnectionWithCredentials(device: device, service: service, credentials: savedCreds)
+        } else {
+            // –ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º credentials
+            pendingConnection = (device, service)
+            showCredentialsSheet = true
+        }
+    }
+    
+    // MARK: - Perform Connection
+    private func performConnectionWithCredentials(device: Device, service: ServiceType, credentials: ConnectionCredentials) {
+        switch service {
+        case .ssh:
+            sshDevice = device
+            sshCredentials = credentials
+            showSSHTerminal = true
+            
+        case .ftp, .sftp:
+            ftpDevice = device
+            ftpServiceType = service
+            ftpCredentials = credentials
+            showFileManager = true
+            
+        case .rdp:
+            rdpDevice = device
+            rdpCredentials = credentials
+            showRDP = true
+            
+        case .vnc:
+            if let url = URL(string: "vnc://\(device.ip)") {
+                NSWorkspace.shared.open(url)
+            }
+        }
+    }
+    
+    // MARK: - Handle Session Connect
+    private func handleSessionConnect(_ session: SavedSession) {
+        performConnectionWithCredentials(
+            device: session.device,
+            service: session.serviceType,
+            credentials: session.credentials
+        )
+    }
+}
+
+// MARK: - Connection Credentials
+struct ConnectionCredentials: Codable {
+    var username: String
+    var password: String
+    var saveCredentials: Bool
+}
+
+// MARK: - Saved Session
+struct SavedSession: Identifiable, Codable {
+    let id = UUID()
+    let name: String
+    let device: Device
+    let serviceType: ServiceType
+    let credentials: ConnectionCredentials
+}
diff --git a/Local Scope/Views/HistoryView.swift b/Local Scope/Views/HistoryView.swift
new file mode 100644
index 0000000..d867fae
--- /dev/null
+++ b/Local Scope/Views/HistoryView.swift	
@@ -0,0 +1,150 @@
+//
+//  HistoryView.swift
+//  Local Scope
+//
+
+import SwiftUI
+
+struct HistoryView: View {
+    let history: [Device]
+    let onConnect: (Device, ServiceType) -> Void
+    let onDelete: (Device) -> Void
+    
+    var sortedHistory: [Device] {
+        history.sorted { $0.lastSeen > $1.lastSeen }
+    }
+    
+    var body: some View {
+        VStack {
+            HStack {
+                Image(systemName: "clock.arrow.circlepath")
+                    .font(.title2)
+                    .foregroundStyle(.purple)
+                Text("Connection History")
+                    .font(.title2.bold())
+                Spacer()
+                Label("\(history.count)", systemImage: "number")
+                    .font(.caption)
+                    .foregroundStyle(.secondary)
+                    .padding(.horizontal, 8)
+                    .padding(.vertical, 4)
+                    .background(Color.purple.opacity(0.1))
+                    .cornerRadius(6)
+            }
+            .padding(.horizontal)
+            .padding(.top, 10)
+            
+            if history.isEmpty {
+                Spacer()
+                VStack(spacing: 12) {
+                    Image(systemName: "clock.badge.questionmark")
+                        .font(.system(size: 48))
+                        .foregroundStyle(.secondary)
+                    Text("No history yet")
+                        .font(.headline)
+                        .foregroundStyle(.secondary)
+                    Text("Scan the network to find devices")
+                        .font(.caption)
+                        .foregroundStyle(.tertiary)
+                }
+                Spacer()
+            } else {
+                ScrollView {
+                    LazyVStack(spacing: 12) {
+                        ForEach(sortedHistory) { device in
+                            HistoryCard(device: device, onConnect: onConnect, onDelete: onDelete)
+                        }
+                    }
+                    .padding()
+                }
+            }
+        }
+    }
+}
+
+struct HistoryCard: View {
+    let device: Device
+    let onConnect: (Device, ServiceType) -> Void
+    let onDelete: (Device) -> Void
+    
+    var body: some View {
+        VStack(spacing: 8) {
+            HStack(spacing: 12) {
+                ZStack {
+                    Circle()
+                        .fill(getDeviceColor(for: device.name).opacity(0.15))
+                        .frame(width: 50, height: 50)
+                    Text(getDeviceEmoji(for: device.name))
+                        .font(.system(size: 24))
+                }
+                
+                VStack(alignment: .leading, spacing: 4) {
+                    Text(device.name)
+                        .font(.headline)
+                    Text(device.ip)
+                        .font(.system(size: 12, weight: .medium))
+                        .foregroundStyle(.blue)
+                    Text("Last seen: \(formattedDate(device.lastSeen))")
+                        .font(.caption)
+                        .foregroundStyle(.secondary)
+                }
+                
+                Spacer()
+                
+                Button(action: { onDelete(device) }) {
+                    Image(systemName: "trash")
+                        .foregroundStyle(.red)
+                }
+                .buttonStyle(.plain)
+            }
+            
+            if !device.availableServices.isEmpty {
+                Divider()
+                HStack(spacing: 8) {
+                    ForEach(device.availableServices, id: \.self) { service in
+                        Button {
+                            onConnect(device, service)
+                        } label: {
+                            HStack(spacing: 4) {
+                                Image(systemName: service.icon)
+                                Text(service.rawValue)
+                            }
+                            .font(.caption)
+                            .padding(.horizontal, 8)
+                            .padding(.vertical, 4)
+                            .background(service.color.opacity(0.1))
+                            .foregroundStyle(service.color)
+                            .cornerRadius(6)
+                        }
+                        .buttonStyle(.plain)
+                    }
+                }
+            }
+        }
+        .padding()
+        .background(RoundedRectangle(cornerRadius: 12).fill(Color.gray.opacity(0.05)))
+        .overlay(RoundedRectangle(cornerRadius: 12).stroke(Color.gray.opacity(0.2), lineWidth: 1))
+    }
+    
+    private func formattedDate(_ date: Date) -> String {
+        let formatter = RelativeDateTimeFormatter()
+        formatter.unitsStyle = .full
+        return formatter.localizedString(for: date, relativeTo: Date())
+    }
+    
+    private func getDeviceColor(for name: String) -> Color {
+        if name.contains("Router") { return .orange }
+        if name.contains("Apple") { return .gray }
+        if name.contains("Android") { return .green }
+        if name.contains("Smart TV") { return .purple }
+        return .blue
+    }
+    
+    private func getDeviceEmoji(for name: String) -> String {
+        if name.contains("Router") { return "üåê" }
+        if name.contains("Apple") { return "üì±" }
+        if name.contains("Android") { return "üì±" }
+        if name.contains("Smart TV") { return "üì∫" }
+        return "üíª"
+    }
+}
diff --git a/Local Scope/Views/NetworkMapView.swift b/Local Scope/Views/NetworkMapView.swift
new file mode 100644
index 0000000..523b605
--- /dev/null
+++ b/Local Scope/Views/NetworkMapView.swift	
@@ -0,0 +1,98 @@
+//
+//  NetworkMapView.swift
+//  Local Scope
+//
+
+import SwiftUI
+
+struct NetworkMapView: View {
+    @Binding var devices: [Device]
+    @Binding var localIP: String
+    @Binding var scanning: Bool
+    @Binding var progress: Double
+    let onScan: () -> Void
+    let onDeviceSelect: (Device) -> Void
+    let onDeviceConnect: ((Device, ServiceType) -> Void)?
+    let onAddToFavorites: ((Device, ServiceType) -> Void)?
+    
+    var body: some View {
+        VStack(spacing: 20) {
+            Text("Local Network Map")
+                .font(.title.bold())
+                .padding(.top, 10)
+            
+            HStack(spacing: 8) {
+                Image(systemName: "network")
+                    .foregroundStyle(.blue)
+                Text("Local IP: \(localIP)")
+                    .font(.headline)
+            }
+            .padding(.horizontal)
+            .padding(.vertical, 8)
+            .background(Color.blue.opacity(0.1))
+            .cornerRadius(10)
+            
+            if scanning {
+                VStack(spacing: 8) {
+                    ProgressView(value: progress, total: 1.0)
+                        .tint(.blue)
+                    Text("Scanning network... \(Int(progress * 100))%")
+                        .font(.caption)
+                        .foregroundStyle(.secondary)
+                }
+                .padding()
+            }
+            
+            ZStack {
+                LinearGradient(
+                    colors: [Color.blue.opacity(0.05), Color.purple.opacity(0.05)],
+                    startPoint: .topLeading,
+                    endPoint: .bottomTrailing
+                )
+                
+                InteractiveNetworkCanvas(
+                    devices: devices,
+                    localIP: localIP,
+                    onDeviceSelect: onDeviceSelect,
+                    onDeviceConnect: onDeviceConnect,
+                    onAddToFavorites: onAddToFavorites
+                )
+            }
+            .frame(maxWidth: .infinity, maxHeight: .infinity)
+            .background(
+                RoundedRectangle(cornerRadius: 16)
+                    .fill(Color.gray.opacity(0.05))
+                    .shadow(color: .black.opacity(0.1), radius: 10)
+            )
+            .padding()
+            
+            HStack(spacing: 20) {
+                Label("\(devices.count) devices", systemImage: "antenna.radiowaves.left.and.right")
+                    .font(.caption.bold())
+                    .foregroundStyle(.secondary)
+                    .padding(.horizontal, 12)
+                    .padding(.vertical, 6)
+                    .background(Color.green.opacity(0.1))
+                    .cornerRadius(8)
+                
+                if !devices.isEmpty {
+                    Label("Online", systemImage: "checkmark.circle.fill")
+                        .font(.caption.bold())
+                        .foregroundStyle(.green)
+                }
+            }
+            
+            Button(action: onScan) {
+                HStack {
+                    Image(systemName: scanning ? "stop.circle.fill" : "play.circle.fill")
+                    Text(scanning ? "Stop Scan" : "Start Scan")
+                        .fontWeight(.semibold)
+                }
+                .frame(maxWidth: 200)
+            }
+            .buttonStyle(.borderedProminent)
+            .controlSize(.large)
+            .padding(.bottom, 20)
+        }
+    }
+}
diff --git a/Local Scope/Views/SettingsView.swift b/Local Scope/Views/SettingsView.swift
new file mode 100644
index 0000000..19053ef
--- /dev/null
+++ b/Local Scope/Views/SettingsView.swift	
@@ -0,0 +1,69 @@
+//
+//  SettingsView.swift
+//  Local Scope
+//
+
+import SwiftUI
+
+struct SettingsView: View {
+    let onReload: () -> Void
+    let onClear: () -> Void
+    
+    var body: some View {
+        ScrollView {
+            VStack(spacing: 24) {
+                Text("Settings")
+                    .font(.title.bold())
+                    .padding(.top, 10)
+                
+                VStack(spacing: 12) {
+                    Image(systemName: "network.badge.shield.half.filled")
+                        .font(.system(size: 60))
+                        .foregroundStyle(LinearGradient(
+                            colors: [.blue, .purple],
+                            startPoint: .topLeading,
+                            endPoint: .bottomTrailing
+                        ))
+                    Text("LocalScope")
+                        .font(.title2.bold())
+                    Text("Network Scanner & Device Manager")
+                        .font(.caption)
+                        .foregroundStyle(.secondary)
+                    Text("Version 1.0")
+                        .font(.caption2)
+                        .foregroundStyle(.tertiary)
+                }
+                .padding()
+                .background(RoundedRectangle(cornerRadius: 16).fill(Color.blue.opacity(0.05)))
+                .padding(.horizontal)
+                
+                GroupBox {
+                    VStack(spacing: 16) {
+                        SettingsButton(
+                            icon: "arrow.clockwise",
+                            title: "Reload History",
+                            subtitle: "Refresh device history",
+                            color: .blue,
+                            action: onReload
+                        )
+                        Divider()
+                        SettingsButton(
+                            icon: "trash",
+                            title: "Clear History",
+                            subtitle: "Delete all records",
+                            color: .red,
+                            action: onClear
+                        )
+                    }
+                    .padding()
+                } label: {
+                    Label("Data Management", systemImage: "folder.badge.gearshape")
+                        .font(.headline)
+                }
+                .padding(.horizontal)
+                
+                Spacer()
+            }
+        }
+    }
+}
